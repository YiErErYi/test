<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3DÂÖâÂ≠¶Á≥ªÁªüËÆæËÆ°Ê∏∏Êàè - Â¢ûÂº∫Áâà</title>
    <!-- Babylon.js Ê†∏ÂøÉÂ∫ì -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <!-- Babylon.js Âä†ËΩΩÂô® -->
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <!-- Babylon.js GUI -->
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <!-- ÊùêË¥®Â∫ì -->
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
            outline: none;
            touch-action: none;
        }

        #uiPanel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 340px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            z-index: 100;
        }

        .panel {
            background: rgba(0, 20, 40, 0.9);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 8px 32px rgba(0, 255, 255, 0.2);
        }

        .panel h3 {
            color: #00ffff;
            margin-bottom: 10px;
            text-align: center;
            font-size: 16px;
            text-shadow: 0 0 10px #00ffff;
        }

        .component-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .component-btn {
            background: linear-gradient(45deg, #0a1a2a, #1a3a5a);
            border: 1px solid #00aacc;
            border-radius: 8px;
            padding: 10px 5px;
            color: #ffffff;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            display: -webkit-flex; /* Safari 6.1+ */
            display: flex;
            -webkit-flex-direction: column; /* Safari 6.1+ */
            flex-direction: column;
            -webkit-align-items: center; /* Safari 7.1+ */
            align-items: center;
            gap: 5px;
            -webkit-user-select: none; /* Safari 3+ */
            user-select: none;
        }

        .component-btn:hover {
            background: linear-gradient(45deg, #1a3a5a, #2a4a6a);
            border-color: #00ffff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            -webkit-transform: translateY(-2px); /* Safari 3.1+ */
            transform: translateY(-2px);
        }

        .component-btn.selected {
            background: linear-gradient(45deg, #00aacc, #0088aa);
            border-color: #ffffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
        }

        .component-btn .icon {
            font-size: 20px;
            line-height: 1;
        }

        .component-btn span {
            font-size: 11px;
            font-weight: bold;
        }

        #propertyControls {
            color: #ffffff;
            min-height: 60px;
        }

        .property-group {
            margin-bottom: 15px;
        }

        .property-group label {
            display: block;
            margin-bottom: 5px;
            color: #00ccff;
            font-size: 12px;
            font-weight: bold;
        }

        .property-group input,
        .property-group select {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #00aacc;
            border-radius: 4px;
            background: rgba(0, 50, 100, 0.7);
            color: #ffffff;
            font-size: 12px;
        }

        .property-group input:focus,
        .property-group select:focus {
            outline: none;
            border-color: #00ffff;
            box-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
        }

        .property-group button {
            width: 100%;
            padding: 8px;
            background: linear-gradient(45deg, #cc3300, #ff4400);
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            margin-top: 5px;
        }

        .property-group button:hover {
            background: linear-gradient(45deg, #ff4400, #ff6600);
            box-shadow: 0 0 10px rgba(255, 68, 0, 0.5);
        }

        .prop-slider {
            display: -webkit-flex; /* Safari 6.1+ */
            display: flex;
            -webkit-align-items: center; /* Safari 7.1+ */
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .prop-slider label {
            min-width: 90px;
            font-size: 11px;
            margin-bottom: 0;
        }

        .prop-slider input[type="range"] {
            -webkit-flex: 1; /* Safari 6.1+ */
            flex: 1;
            height: 20px;
        }

        .prop-slider input[type="number"] {
            width: 70px;
            padding: 2px 4px;
            font-size: 11px;
        }

        .prop-color {
            display: -webkit-flex; /* Safari 6.1+ */
            display: flex;
            -webkit-align-items: center; /* Safari 7.1+ */
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .prop-color label {
            min-width: 90px;
            font-size: 11px;
            margin-bottom: 0;
        }

        .prop-color input[type="color"] {
            width: 40px;
            height: 25px;
            border: none;
            border-radius: 4px;
        }

        #systemInfo {
            color: #ffffff;
            font-size: 12px;
            line-height: 1.4;
        }

        #systemInfo div {
            margin-bottom: 8px;
            padding: 5px;
            background: rgba(0, 100, 150, 0.3);
            border-radius: 4px;
            border-left: 3px solid #00ffff;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 20, 40, 0.9);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 15px;
            color: #ffffff;
            box-shadow: 0 8px 32px rgba(0, 255, 255, 0.2);
            max-width: 250px;
        }

        #controls h4 {
            color: #00ffff;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #00ffff;
        }

        #controls p {
            margin-bottom: 5px;
            font-size: 12px;
        }

        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            display: -webkit-flex; /* Safari 6.1+ */
            display: flex;
            -webkit-justify-content: center; /* Safari 7.1+ */
            justify-content: center;
            -webkit-align-items: center; /* Safari 7.1+ */
            align-items: center;
            z-index: 9999;
            color: white;
            text-align: center;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #00ffff;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { 
                -webkit-transform: rotate(0deg); /* Safari 3.1+ */
                transform: rotate(0deg); 
            }
            100% { 
                -webkit-transform: rotate(360deg); /* Safari 3.1+ */
                transform: rotate(360deg); 
            }
        }

        .hidden {
            display: none !important;
        }

        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 50, 100, 0.3);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb {
            background: #00aacc;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #00ffff;
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <div>
            <div class="spinner"></div>
            <p>Ê≠£Âú®Âä†ËΩΩ3DÂÖâÂ≠¶Á≥ªÁªü...</p>
        </div>
    </div>

    <div id="gameContainer" class="hidden">
        <canvas id="renderCanvas"></canvas>
        
        <!-- UIÈù¢Êùø -->
        <div id="uiPanel">
            <div id="componentPanel" class="panel">
                <h3>ÂÖâÂ≠¶ÁªÑ‰ª∂</h3>
                <div class="component-grid">
                    <button class="component-btn" data-type="laser">
                        <div class="icon">üí°</div>
                        <span>ÊøÄÂÖâÊ∫ê</span>
                    </button>
                    <button class="component-btn" data-type="lens" data-subtype="convex">
                        <div class="icon">üîç</div>
                        <span>ÈÄèÈïú</span>
                    </button>
                    <button class="component-btn" data-type="mirror" data-subtype="plane">
                        <div class="icon">ü™û</div>
                        <span>Âπ≥Èù¢Èïú</span>
                    </button>
                    <button class="component-btn" data-type="mirror" data-subtype="concave">
                        <div class="icon">üåô</div>
                        <span>ÂáπÈù¢Èïú</span>
                    </button>
                    <button class="component-btn" data-type="prism">
                        <div class="icon">üî∫</div>
                        <span>‰∏âÊ£±Èïú</span>
                    </button>
                    <button class="component-btn" data-type="grating">
                        <div class="icon">‚ñ§</div>
                        <span>Ë°çÂ∞ÑÂÖâÊ†Ö</span>
                    </button>
                    <button class="component-btn" data-type="screen">
                        <div class="icon">üñ•Ô∏è</div>
                        <span>Â±èÂπï</span>
                    </button>
                </div>
            </div>

            <div id="propertiesPanel" class="panel">
                <h3>ÁªÑ‰ª∂Â±ûÊÄß</h3>
                <div id="propertyControls">
                    <p>ÈÄâÊã©‰∏Ä‰∏™ÁªÑ‰ª∂Êù•ÁºñËæëÂ±ûÊÄß</p>
                </div>
            </div>

            <div id="infoPanel" class="panel">
                <h3>Á≥ªÁªü‰ø°ÊÅØ</h3>
                <div id="systemInfo">
                    <div id="distanceInfo">Ë∑ùÁ¶ª‰ø°ÊÅØ: Á≠âÂæÖÁªÑ‰ª∂Ê∑ªÂä†</div>
                    <div id="rayInfo">ÂÖâÁ∫ø‰ø°ÊÅØ: 0Êù°ÂÖâÁ∫ø</div>
                    <div id="performanceInfo">ÊÄßËÉΩ‰ø°ÊÅØ: Ê≠£Âú®ÂàùÂßãÂåñ...</div>
                </div>
                
                <!-- ÊÄßËÉΩÊéßÂà∂Èù¢Êùø -->
                <div style="margin-top: 15px; padding: 8px; background: rgba(255, 100, 0, 0.1); border-radius: 4px; border: 1px solid #ff6400;">
                    <h4 style="margin: 0 0 8px 0; color: #ff6400;">üî• ÊûÅÈôêÊÄßËÉΩÊ®°Âºè</h4>
                    <div style="font-size: 11px;">
                        <label><input type="checkbox" id="realtimeRayTracing" checked> ÂÆûÊó∂ÂÖâÁ∫øËøΩË∏™</label><br>
                        <label><input type="checkbox" id="forceRender" checked> Âº∫Âà∂ÊØèÂ∏ßÊ∏≤Êüì</label><br>
                        <label><input type="checkbox" id="advancedRayTracing" checked> È´òÁ∫ßÂÖâÁ∫øËøΩË∏™</label><br>
                        <label><input type="checkbox" id="maxGpuLoad" checked> ÊúÄÂ§ßGPUË¥üËΩΩ</label><br>
                        <div style="margin-top: 5px;">
                            <label>ÂÖâÁ∫øÂØÜÂ∫¶: <input type="range" id="rayDensity" min="1" max="10" value="3" style="width: 60px;"></label>
                            <span id="rayDensityValue">3</span>
                        </div>
                        <div>
                            <label>ÊúÄÂ§ßÂèçÂºπ: <input type="range" id="maxBounces" min="10" max="200" value="100" style="width: 60px;"></label>
                            <span id="maxBouncesValue">100</span>
                        </div>
                        <div>
                            <label>Ê∏≤ÊüìÂàÜËæ®Áéá: <input type="range" id="renderScale" min="50" max="200" value="100" style="width: 60px;"></label>
                            <span id="renderScaleValue">100%</span>
                        </div>
                        <div>
                            <label>ÁõÆÊ†áFPS: <input type="range" id="targetFps" min="30" max="240" value="144" style="width: 60px;"></label>
                            <span id="targetFpsValue">144</span>
                        </div>
                        <div style="margin-top: 5px;">
                            <button id="forceGpuStress" style="padding: 2px 6px; font-size: 10px; background: #ff4444; color: white; border: none; border-radius: 2px; cursor: pointer;">
                                üî• GPUÂéãÂäõÊµãËØï
                            </button>
                            <button id="optimizeMemory" style="padding: 2px 6px; font-size: 10px; background: #44ff44; color: black; border: none; border-radius: 2px; cursor: pointer; margin-left: 4px;">
                                üßπ ÂÜÖÂ≠ò‰ºòÂåñ
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ÊéßÂà∂ËØ¥Êòé -->
        <div id="controls">
            <h4>ÊéßÂà∂ËØ¥Êòé</h4>
            <p> Èº†Ê†áÂ∑¶ÈîÆ: ÈÄâÊã©ÁªÑ‰ª∂</p>
            <p> Èº†Ê†áÊãñÊãΩ: ÊóãËΩ¨ËßÜËßí</p>
            <p>üîÑ T/RÈîÆ: ÂàáÊç¢ÁßªÂä®/ÊóãËΩ¨Ê®°Âºè</p>
            <p>‚¨ÜÔ∏è‚¨áÔ∏è ÊñπÂêëÈîÆ: ÂæÆË∞É‰ΩçÁΩÆ</p>
            <p>üîç Èº†Ê†áÊªöËΩÆ: Áº©ÊîæËßÜÂõæ</p>
            <p>üóëÔ∏è DelÈîÆ: Âà†Èô§ÈÄâ‰∏≠ÁªÑ‰ª∂</p>
            <p>‚å®Ô∏è EscÈîÆ: ÂèñÊ∂àÈÄâÊã©</p>
            <p style="color: #ff6400;">‚ö° ÂÆûÊó∂Ê∏≤ÊüìÊ®°ÂºèÂ∑≤ÂêØÁî®</p>
        </div>
    </div>

    <script>
        // Á≠âÂæÖBabylon.jsÂä†ËΩΩÂÆåÊàê
        function waitForBabylon() {
            return new Promise((resolve, reject) => {
                let attempts = 0;
                const maxAttempts = 100;
                
                function check() {
                    attempts++;
                    console.log(`Ê£ÄÊü•Babylon.jsÂä†ËΩΩÁä∂ÊÄÅ: ${attempts}/${maxAttempts}`);
                    
                    if (typeof BABYLON !== 'undefined' && 
                        BABYLON.Engine && 
                        BABYLON.Scene && 
                        BABYLON.ArcRotateCamera &&
                        BABYLON.Vector3) {
                        console.log('Babylon.js Âä†ËΩΩÂÆåÊàê');
                        resolve();
                    } else if (attempts >= maxAttempts) {
                        reject(new Error('Babylon.js Âä†ËΩΩË∂ÖÊó∂'));
                    } else {
                        setTimeout(check, 100);
                    }
                }
                
                check();
            });
        }

        class OpticalSystem {
            constructor() {
                this.canvas = null;
                this.engine = null;
                this.scene = null;
                this.camera = null;
                this.gizmoManager = null;
                this.selectedComponent = null;
                this.components = [];
                this.rayLines = [];
                this.maxBounces = 100; // ÈªòËÆ§Êõ¥È´òÁöÑÂèçÂºπÊ¨°Êï∞
                this.needsRayUpdate = true;
                this.lastRayUpdateTime = 0;
                this.rayUpdateInterval = 0; // ËÆæÁΩÆ‰∏∫0ÔºåÂÆûÊó∂Êõ¥Êñ∞ÂÖâÁ∫øËøΩË∏™
                this.transformMode = 'translate'; // ÈªòËÆ§ÁßªÂä®Ê®°Âºè
                
                // ÁÆÄÂçïÊãñÊãΩÂèòÈáè
                this.isDragging = false;
                this.dragStartPoint = null;
                this.dragStartObjectPosition = null;
                
                // ÊÄßËÉΩ‰ºòÂåñÂèòÈáè
                this.enableRealtimeRayTracing = true; // ÂêØÁî®ÂÆûÊó∂ÂÖâÁ∫øËøΩË∏™
                this.rayDensity = 3; // ÈªòËÆ§ÂÖâÁ∫øÂØÜÂ∫¶
                this.maxGpuLoad = true; // ÈªòËÆ§ÂêØÁî®ÊúÄÂ§ßGPUË¥üËΩΩ
                this.targetFPS = 144; // ÁõÆÊ†áFPS
                this.gpuStressObjects = null; // GPUÂéãÂäõÊµãËØïÂØπË±°
                this.enableHighPerformanceMode = true; // ÂêØÁî®È´òÊÄßËÉΩÊ®°Âºè
                this.maxFPS = 0; // 0Ë°®Á§∫‰∏çÈôêÂà∂FPS
                this.forceRender = true; // Âº∫Âà∂ÊØèÂ∏ßÊ∏≤Êüì
                this.maxBounces = 50; // Â¢ûÂä†ÊúÄÂ§ßÂèçÂºπÊ¨°Êï∞‰ª•Ëé∑ÂæóÊõ¥Á≤æÁ°ÆÁöÑÂÖâÁ∫øËøΩË∏™
                this.rayDensity = 1; // ÂÖâÁ∫øÂØÜÂ∫¶ÔºàÂèØ‰ª•Â¢ûÂä†‰ª•Ëé∑ÂæóÊõ¥Â§öÂÖâÁ∫øÔºâ
                this.enableAdvancedRayTracing = true; // ÂêØÁî®È´òÁ∫ßÂÖâÁ∫øËøΩË∏™
                
                console.log('ÂºÄÂßãÂàùÂßãÂåñÂÖâÂ≠¶Á≥ªÁªü...');
                this.init();
            }

            async init() {
                try {                    // Á≠âÂæÖBabylon.jsÂÆåÂÖ®Âä†ËΩΩ
                    await waitForBabylon();
                    
                    // Á≠âÂæÖDOMÂÆåÂÖ®Âä†ËΩΩ
                    if (document.readyState !== 'complete') {
                        await new Promise(resolve => window.addEventListener('load', resolve));
                    }

                    console.log('Ëé∑ÂèñÁîªÂ∏ÉÂÖÉÁ¥†...');
                    this.canvas = document.getElementById('renderCanvas');
                    if (!this.canvas) {
                        throw new Error('Êó†Ê≥ïÊâæÂà∞ÁîªÂ∏ÉÂÖÉÁ¥†');
                    }

                    console.log('ÂàõÂª∫Babylon.jsÂºïÊìé...');
                    // Âº∫Âà∂ÂêØÁî®Áã¨Á´ãGPUÂíåÊúÄÂ§ßÊÄßËÉΩÈÖçÁΩÆ
                    this.engine = new BABYLON.Engine(this.canvas, true, {
                        preserveDrawingBuffer: false, // Á¶ÅÁî®‰ª•ËäÇÁúÅÊòæÂ≠ò
                        stencil: true,
                        depth: true,
                        powerPreference: "high-performance", // Âº∫Âà∂È´òÊÄßËÉΩGPU
                        antialias: false, // ÂÖ≥Èó≠ÊäóÈîØÈΩø‰ª•ÊúÄÂ§ßÂåñÊÄßËÉΩ
                        adaptToDeviceRatio: false, // Á¶ÅÁî®ËÆæÂ§áÂÉèÁ¥†ÊØîÈÄÇÈÖç
                        premultipliedAlpha: false,
                        doNotHandleContextLost: true,
                        audioEngine: false, // Á¶ÅÁî®Èü≥È¢ëÂºïÊìé
                        deterministicLockstep: false, // Á¶ÅÁî®ÈîÅÊ≠•
                        lockstepMaxSteps: 1,
                        useHighPrecisionMatrix: true,
                        failIfMajorPerformanceCaveat: false, // ÂÖÅËÆ∏ËΩØ‰ª∂Ê∏≤Êüì
                        xrCompatible: false, // Á¶ÅÁî®VRÂÖºÂÆπ
                        desynchronized: true, // ÂêØÁî®ÂºÇÊ≠•Ê∏≤Êüì
                        alpha: false, // Á¶ÅÁî®ÈÄèÊòéÂ∫¶‰ª•ÊèêÂçáÊÄßËÉΩ
                        // WebGL2Âº∫Âà∂ÂêØÁî®
                        webglVersion: 2,
                        // ÊúÄÂ§ßÊòæÂ≠òÂíåGPUÂà©Áî®ÁéáËÆæÁΩÆ
                        forcedExtensions: ['WEBGL_lose_context', 'OES_texture_float', 'WEBGL_depth_texture']
                    });

                    // ËÆæÁΩÆÂºïÊìé‰∏∫ÊûÅÈôêÊÄßËÉΩÊ®°Âºè
                    if (this.enableHighPerformanceMode) {
                        // Âº∫Âà∂ÊúÄÈ´òÁ°¨‰ª∂Âä†ÈÄü
                        this.engine.setHardwareScalingLevel(0.5); // Èôç‰ΩéÂàÜËæ®Áéá‰ª•ÊúÄÂ§ßÂåñÂ∏ßÁéá
                        this.engine.disableOfflineSupport = true;
                        this.engine.enableOfflineSupport = false;
                        
                        // Âº∫Âà∂ËÆæÁΩÆÈ´òÂà∑Êñ∞ÁéáÂíåÊúÄÂ§ßÊòæÂ≠ò‰ΩøÁî®
                        this.engine.setSize(window.innerWidth, window.innerHeight, false);
                        
                        // WebGLÁä∂ÊÄÅ‰ºòÂåñ
                        const gl = this.engine._gl;
                        if (gl) {
                            // Á¶ÅÁî®Ê∑±Â∫¶ÂÜôÂÖ•‰ºòÂåñÔºàÂú®‰∏çÈúÄË¶ÅÊó∂Ôºâ
                            gl.disable(gl.DITHER);
                            // ÂêØÁî®Á°¨‰ª∂‰ºòÂåñ
                            gl.hint(gl.FRAGMENT_SHADER_DERIVATIVE_HINT, gl.FASTEST);
                            // ÊúÄÂ§ßÂåñÁ∫πÁêÜÂçïÂÖÉ‰ΩøÁî®
                            console.log('WebGLÊúÄÂ§ßÁ∫πÁêÜÂçïÂÖÉ:', gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS));
                        }
                        
                        // Âº∫Âà∂ÂûÇÁõ¥ÂêåÊ≠•ÂÖ≥Èó≠ÔºàÂ¶ÇÊûúÂèØËÉΩÔºâ
                        this.canvas.style.imageRendering = 'pixelated'; // Á¶ÅÁî®ÂõæÂÉèÂπ≥Êªë
                        
                        console.log('üî• ÊûÅÈôêÊÄßËÉΩÊ®°ÂºèÂ∑≤ÂêØÁî® - GPUÂä†ÈÄüÊúÄÂ§ßÂåñ');
                    }

                    if (!this.engine) {
                        throw new Error('Êó†Ê≥ïÂàõÂª∫Babylon.jsÂºïÊìé');
                    }

                    console.log('ÂàõÂª∫Âú∫ÊôØ...');
                    this.createScene();
                    
                    console.log('ÂàõÂª∫Áõ∏Êú∫...');
                    await this.createCamera();
                    
                    console.log('ÂàõÂª∫ÂÖâÁÖß...');
                    this.createLighting();
                    
                    console.log('ÂàõÂª∫ÁéØÂ¢É...');
                    this.createEnvironment();
                    
                    console.log('ËÆæÁΩÆGizmoÁÆ°ÁêÜÂô®...');
                    this.setupGizmoManager();
                    
                    // üî• ÊûÅÈôêÊÄßËÉΩ‰ºòÂåñËÆæÁΩÆ
                    this.setupExtremePerformanceMode();
                    
                    console.log('ËÆæÁΩÆ‰∫ã‰ª∂ÁõëÂê¨Âô®...');
                    this.setupEventListeners();
                    
                    console.log('ÂêØÂä®Ê∏≤ÊüìÂæ™ÁéØ...');
                    this.startRenderLoop();
                    
                    // ÈöêËóèÂä†ËΩΩÂ±èÂπï
                    document.getElementById('loadingScreen').classList.add('hidden');
                    document.getElementById('gameContainer').classList.remove('hidden');
                    
                    console.log('ÂÖâÂ≠¶Á≥ªÁªüÂàùÂßãÂåñÂÆåÊàê!');
                    
                } catch (error) {
                    console.error('ÂàùÂßãÂåñÂ§±Ë¥•:', error);
                    this.showError(error.message);
                }
            }

            showError(message) {
                const loadingScreen = document.getElementById('loadingScreen');
                if (loadingScreen) {
                    loadingScreen.innerHTML = `
                        <div style="color: #ff4444; text-align: center; padding: 20px;">
                            <h3>‚ùå ÂàùÂßãÂåñÂ§±Ë¥•</h3>
                            <p style="margin: 20px 0;">${message}</p>
                            <p style="font-size: 12px; margin: 10px 0;">ËØ∑Ê£ÄÊü•ÊµèËßàÂô®ÊòØÂê¶ÊîØÊåÅWebGL</p>
                            <button onclick="location.reload()" style="padding: 10px 20px; background: #ff4444; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 10px;">
                                ÈáçÊñ∞Âä†ËΩΩ
                            </button>
                        </div>
                    `;
                }
            }

            createScene() {
                this.scene = new BABYLON.Scene(this.engine);
                this.scene.clearColor = new BABYLON.Color3(0.1, 0.1, 0.15);
                
                // ÊÄßËÉΩ‰ºòÂåñËÆæÁΩÆ
                if (this.enableHighPerformanceMode) {
                    this.scene.skipPointerMovePicking = false; // ‰øùÊåÅÁ≤æÁ°ÆÁöÑÈº†Ê†áÊãæÂèñ
                    this.scene.autoClear = true; // ÂêØÁî®Ëá™Âä®Ê∏ÖÈô§
                    this.scene.autoClearDepthAndStencil = true; // ÂêØÁî®Ê∑±Â∫¶ÂíåÊ®°ÊùøËá™Âä®Ê∏ÖÈô§
                    this.scene.blockMaterialDirtyMechanism = false; // ÂêØÁî®ÊùêË¥®ËÑèÊ£ÄÊü•Êú∫Âà∂
                    this.scene.useDelayedTextureLoading = false; // Á¶ÅÁî®Âª∂ËøüÁ∫πÁêÜÂä†ËΩΩ‰ª•Ëé∑ÂæóÊõ¥Â•ΩÁöÑÂìçÂ∫îÊÄß
                    this.scene.probesEnabled = true; // ÂêØÁî®Êé¢Èíà
                    this.scene.lightsEnabled = true; // Á°Æ‰øùÂÖâÁÖßÂêØÁî®
                    this.scene.shadowsEnabled = true; // ÂêØÁî®Èò¥ÂΩ±
                    this.scene.particlesEnabled = true; // ÂêØÁî®Á≤íÂ≠êÁ≥ªÁªü
                    this.scene.spritesEnabled = false; // Á¶ÅÁî®Á≤æÁÅµ‰ª•ËäÇÁúÅÊÄßËÉΩ
                    this.scene.skeletonsEnabled = false; // Á¶ÅÁî®È™®È™ºÂä®Áîª‰ª•ËäÇÁúÅÊÄßËÉΩ
                    this.scene.lensFlaresEnabled = false; // Á¶ÅÁî®ÈïúÂ§¥ÂÖâÊôï‰ª•ËäÇÁúÅÊÄßËÉΩ
                    this.scene.collisionsEnabled = false; // Á¶ÅÁî®Á¢∞ÊíûÊ£ÄÊµã‰ª•ËäÇÁúÅÊÄßËÉΩ
                    this.scene.physicsEnabled = false; // Á¶ÅÁî®Áâ©ÁêÜÂºïÊìé‰ª•ËäÇÁúÅÊÄßËÉΩ
                    this.scene.fogEnabled = false; // Á¶ÅÁî®ÈõæÊïà‰ª•ËäÇÁúÅÊÄßËÉΩ
                    
                    // ‰ºòÂåñÊ∏≤ÊüìÊÄßËÉΩ
                    this.scene.freezeActiveMeshes = false; // ‰∏çÂÜªÁªìÊ¥ªÂä®ÁΩëÊ†ºÔºå‰øùÊåÅÂä®ÊÄÅÊõ¥Êñ∞
                    this.scene.constantlyUpdateMeshUnderPointer = true; // ÊåÅÁª≠Êõ¥Êñ∞Èº†Ê†á‰∏ãÁöÑÁΩëÊ†º
                    
                    console.log('Âú∫ÊôØÊÄßËÉΩ‰ºòÂåñÂ∑≤ÂêØÁî®');
                }
                
                console.log('Âú∫ÊôØÂàõÂª∫ÊàêÂäü');
            }

            async createCamera() {
                try {
                    console.log('ÂàõÂª∫ÂºßÂΩ¢ÊóãËΩ¨Áõ∏Êú∫...');
                    
                    this.camera = new BABYLON.ArcRotateCamera(
                        "camera",
                        -Math.PI / 2,
                        Math.PI / 2.5,
                        20,
                        BABYLON.Vector3.Zero(),
                        this.scene
                    );

                    // Áªü‰∏Ä‰ΩøÁî®attachControlÊñπÊ≥ï
                    this.camera.attachControl(this.canvas, true);
                    
                    this.camera.setTarget(BABYLON.Vector3.Zero());
                    
                    // ËÆæÁΩÆÁõ∏Êú∫ÈôêÂà∂
                    this.camera.lowerRadiusLimit = 5;
                    this.camera.upperRadiusLimit = 50;
                    this.camera.lowerBetaLimit = 0.1;
                    this.camera.upperBetaLimit = Math.PI / 2;
                    
                    console.log('Áõ∏Êú∫ËÆæÁΩÆÂÆåÊàê');
                } catch (error) {
                    console.error('Áõ∏Êú∫ÂàõÂª∫Â§±Ë¥•:', error);
                    throw new Error('Êó†Ê≥ïÂàõÂª∫Áõ∏Êú∫');
                }
            }

            createLighting() {
                const light = new BABYLON.HemisphericLight(
                    "light", 
                    new BABYLON.Vector3(0, 1, 0), 
                    this.scene
                );
                light.intensity = 0.8;
                
                // Ê∑ªÂä†ÂÆöÂêëÂÖâ‰ª•Â¢ûÂº∫ÊïàÊûú
                const dirLight = new BABYLON.DirectionalLight(
                    "dirLight",
                    new BABYLON.Vector3(-1, -2, -1),
                    this.scene
                );
                dirLight.intensity = 0.5;
                
                console.log('ÂÖâÁÖßÂàõÂª∫ÊàêÂäü');
            }

            createEnvironment() {
                try {
                    // ÂàõÂª∫ÂÖâÂ≠¶Âπ≥Âè∞
                    const ground = BABYLON.MeshBuilder.CreateGround(
                        "ground", 
                        {width: 20, height: 20}, 
                        this.scene
                    );
                    
                    // ÂàõÂª∫ÁΩëÊ†ºÊùêË¥®
                    const groundMaterial = new BABYLON.StandardMaterial("groundMat", this.scene);
                    groundMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.25);
                    groundMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
                    
                    // Ê∑ªÂä†ÁΩëÊ†ºÁ∫πÁêÜÊïàÊûú
                    const groundTexture = new BABYLON.DynamicTexture("groundTexture", {width: 512, height: 512}, this.scene);
                    const ctx = groundTexture.getContext();
                    
                    // ÁªòÂà∂ÁΩëÊ†º
                    ctx.fillStyle = "#333344";
                    ctx.fillRect(0, 0, 512, 512);
                    ctx.strokeStyle = "#445566";
                    ctx.lineWidth = 1;
                    
                    for (let i = 0; i <= 512; i += 32) {
                        ctx.beginPath();
                        ctx.moveTo(i, 0);
                        ctx.lineTo(i, 512);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(0, i);
                        ctx.lineTo(512, i);
                        ctx.stroke();
                    }
                    
                    groundTexture.update();
                    groundMaterial.diffuseTexture = groundTexture;
                    ground.material = groundMaterial;
                    ground.isPickable = false;
                    
                    console.log('ÁéØÂ¢ÉÂàõÂª∫ÊàêÂäü');
                } catch (error) {
                    console.error('ÁéØÂ¢ÉÂàõÂª∫Â§±Ë¥•:', error);
                }
            }

            setupGizmoManager() {
                try {
                    if (BABYLON.GizmoManager) {
                        this.gizmoManager = new BABYLON.GizmoManager(this.scene);
                        this.gizmoManager.positionGizmoEnabled = true;
                        this.gizmoManager.rotationGizmoEnabled = false; // ÈªòËÆ§ÂÖ≥Èó≠ÊóãËΩ¨
                        this.gizmoManager.scaleGizmoEnabled = false;
                        this.gizmoManager.usePointerToAttachGizmos = false;

                        // Á≠âÂæÖGizmoÂàùÂßãÂåñÂÆåÊàê
                        setTimeout(() => {
                            try {
                                // Ê£ÄÊü•GizmoÊòØÂê¶ÂèØÁî®
                                if (this.gizmoManager.gizmos && 
                                    this.gizmoManager.gizmos.positionGizmo && 
                                    this.gizmoManager.gizmos.rotationGizmo) {
                                    
                                    // ÁõëÂê¨‰ΩçÁΩÆGizmoÊãñÊãΩ‰∫ã‰ª∂
                                    this.gizmoManager.gizmos.positionGizmo.onDragStartObservable.add(() => {
                                        this.camera.detachControl();
                                        console.log('ÂºÄÂßãÊãñÊãΩ‰ΩçÁΩÆGizmo');
                                    });

                                    this.gizmoManager.gizmos.positionGizmo.onDragEndObservable.add(() => {
                                        this.camera.attachControl(this.canvas, true);
                                        this.needsRayUpdate = true;
                                        this.updatePropertiesPanel(); // Êõ¥Êñ∞Â±ûÊÄßÈù¢ÊùøÊòæÁ§∫
                                        console.log('ÁªìÊùüÊãñÊãΩ‰ΩçÁΩÆGizmo');
                                    });

                                    // ÁõëÂê¨ÊóãËΩ¨GizmoÊãñÊãΩ‰∫ã‰ª∂
                                    this.gizmoManager.gizmos.rotationGizmo.onDragStartObservable.add(() => {
                                        this.camera.detachControl();
                                        console.log('ÂºÄÂßãÊãñÊãΩÊóãËΩ¨Gizmo');
                                    });

                                    this.gizmoManager.gizmos.rotationGizmo.onDragEndObservable.add(() => {
                                        this.camera.attachControl(this.canvas, true);
                                        this.needsRayUpdate = true;
                                        this.updatePropertiesPanel(); // Êõ¥Êñ∞Â±ûÊÄßÈù¢ÊùøÊòæÁ§∫
                                        console.log('ÁªìÊùüÊãñÊãΩÊóãËΩ¨Gizmo');
                                    });

                                    // Ê∑ªÂä†ÂÆûÊó∂ÂèòÊç¢ÁõëÂê¨
                                    this.gizmoManager.gizmos.positionGizmo.onDragObservable.add(() => {
                                        this.needsRayUpdate = true;
                                    });

                                    this.gizmoManager.gizmos.rotationGizmo.onDragObservable.add(() => {
                                        this.needsRayUpdate = true;
                                    });
                                    
                                    console.log('Gizmo‰∫ã‰ª∂ÁõëÂê¨Âô®ËÆæÁΩÆÊàêÂäü');
                                } else {
                                    console.warn('GizmoÂØπË±°Êú™Ê≠£Á°ÆÂàùÂßãÂåñ');
                                }
                            } catch (delayedError) {
                                console.error('Âª∂ËøüGizmoËÆæÁΩÆÂ§±Ë¥•:', delayedError);
                            }
                        }, 100); // Âª∂Ëøü100msÁ≠âÂæÖGizmoÂàùÂßãÂåñ
                        
                        console.log('GizmoÁÆ°ÁêÜÂô®ÂàõÂª∫ÊàêÂäü');
                    } else {
                        console.warn('BABYLON.GizmoManager ‰∏çÂèØÁî®ÔºåË∑≥ËøáGizmoËÆæÁΩÆ');
                    }
                } catch (error) {
                    console.error('GizmoÁÆ°ÁêÜÂô®ËÆæÁΩÆÂ§±Ë¥•:', error);
                    this.gizmoManager = null;
                }
            }

            // ËÆæÁΩÆÂèòÊç¢Ê®°Âºè
            setTransformMode(mode) {
                if (!this.gizmoManager) {
                    console.warn('GizmoManager Êú™ÂàùÂßãÂåñ');
                    return;
                }
                
                this.transformMode = mode;
                
                try {
                    if (mode === 'translate') {
                        this.gizmoManager.positionGizmoEnabled = true;
                        this.gizmoManager.rotationGizmoEnabled = false;
                        console.log('ÂàáÊç¢Âà∞ÁßªÂä®Ê®°Âºè');
                    } else if (mode === 'rotate') {
                        this.gizmoManager.positionGizmoEnabled = false;
                        this.gizmoManager.rotationGizmoEnabled = true;
                        console.log('ÂàáÊç¢Âà∞ÊóãËΩ¨Ê®°Âºè');
                    }
                    
                    // Â¶ÇÊûúÊúâÈÄâ‰∏≠ÁöÑÁªÑ‰ª∂ÔºåÈáçÊñ∞ÈôÑÂä†Gizmo‰ª•Â∫îÁî®Êñ∞Ê®°Âºè
                    if (this.selectedComponent) {
                        console.log('ÈáçÊñ∞ÈôÑÂä†GizmoÂà∞ÈÄâ‰∏≠ÁªÑ‰ª∂');
                        // ÂÖàÂàÜÁ¶ªÂÜçÈáçÊñ∞ÈôÑÂä†ÔºåÁ°Æ‰øùÊñ∞Ê®°ÂºèÁîüÊïà
                        this.gizmoManager.attachToMesh(null);
                        setTimeout(() => {
                            if (this.selectedComponent) {
                                this.gizmoManager.attachToMesh(this.selectedComponent.mesh);
                            }
                        }, 50);
                    }
                } catch (error) {
                    console.error('ËÆæÁΩÆÂèòÊç¢Ê®°ÂºèÂ§±Ë¥•:', error);
                }
            }

            setupEventListeners() {
                // ÈîÆÁõò‰∫ã‰ª∂
                document.addEventListener('keydown', (event) => {
                    switch(event.key) {
                        case 'Escape':
                            event.preventDefault();
                            this.clearSelection();
                            break;
                        case 't':
                        case 'T':
                            event.preventDefault();
                            this.setTransformMode('translate');
                            break;
                        case 'r':
                        case 'R':
                            event.preventDefault();
                            this.setTransformMode('rotate');
                            break;
                        case 'Delete':
                        case 'Backspace':
                            event.preventDefault();
                            this.removeSelectedComponent();
                            break;
                    }

                    // ÂæÆË∞ÉÁßªÂä®Ôºà‰øùÁïôÂéüÊúâÂäüËÉΩÔºâ
                    if (this.selectedComponent) {
                        const moveSpeed = event.shiftKey ? 0.5 : 0.1;
                        switch (event.key) {
                            case 'ArrowUp':
                                event.preventDefault();
                                this.selectedComponent.mesh.position.z += moveSpeed;
                                this.needsRayUpdate = true;
                                break;
                            case 'ArrowDown':
                                event.preventDefault();
                                this.selectedComponent.mesh.position.z -= moveSpeed;
                                this.needsRayUpdate = true;
                                break;
                            case 'ArrowLeft':
                                event.preventDefault();
                                this.selectedComponent.mesh.position.x -= moveSpeed;
                                this.needsRayUpdate = true;
                                break;
                            case 'ArrowRight':
                                event.preventDefault();
                                this.selectedComponent.mesh.position.x += moveSpeed;
                                this.needsRayUpdate = true;
                                break;
                        }
                    }
                });

                // Èº†Ê†áÁÇπÂáªÈÄâÊã©ÂíåÊãñÊãΩ
                this.scene.onPointerDown = (evt, pickInfo) => {
                    console.log('Èº†Ê†áÁÇπÂáªÊ£ÄÊµãÂà∞ÔºåpickInfo:', pickInfo);
                    
                    if (pickInfo && pickInfo.hit) {
                        console.log('ÁÇπÂáªÂà∞ÂØπË±°:', pickInfo.pickedMesh?.name);
                        const component = this.components.find(comp => comp.mesh === pickInfo.pickedMesh);
                        console.log('ÊâæÂà∞ÁöÑÁªÑ‰ª∂:', component?.type);
                        
                        if (component) {
                            console.log('ÈÄâÊã©ÁªÑ‰ª∂:', component.type);
                            this.selectComponent(component);
                            
                            // Â¶ÇÊûúGizmo‰∏çÂèØÁî®ÔºåÂêØÁî®ÁÆÄÂçïÊãñÊãΩ
                            if (!this.gizmoManager && evt.button === 0) { // Â∑¶ÈîÆ
                                this.isDragging = true;
                                this.dragStartPoint = this.getGroundPickPoint(evt);
                                this.dragStartObjectPosition = component.mesh.position.clone();
                                this.camera.detachControl();
                                console.log('ÂºÄÂßãÁÆÄÂçïÊãñÊãΩÊ®°Âºè');
                            }
                        } else {
                            console.log('Êú™ÊâæÂà∞ÂØπÂ∫îÁöÑÁªÑ‰ª∂ÔºåÊ∏ÖÈô§ÈÄâÊã©');
                            this.clearSelection();
                        }
                    } else {
                        console.log('Êú™ÁÇπÂáªÂà∞‰ªª‰ΩïÂØπË±°ÔºåÊ∏ÖÈô§ÈÄâÊã©');
                        this.clearSelection();
                    }
                };

                // Èº†Ê†áÁßªÂä®‰∫ã‰ª∂
                this.scene.onPointerMove = (evt) => {
                    if (this.isDragging && this.selectedComponent && this.dragStartPoint) {
                        const currentPoint = this.getGroundPickPoint(evt);
                        if (currentPoint) {
                            const offset = currentPoint.subtract(this.dragStartPoint);
                            this.selectedComponent.mesh.position = this.dragStartObjectPosition.add(offset);
                            this.needsRayUpdate = true;
                        }
                    }
                };

                // Èº†Ê†áÈáäÊîæ‰∫ã‰ª∂
                this.scene.onPointerUp = (evt) => {
                    if (this.isDragging) {
                        this.isDragging = false;
                        this.camera.attachControl(this.canvas, true);
                        this.updatePropertiesPanel();
                        console.log('ÁªìÊùüÁÆÄÂçïÊãñÊãΩÊ®°Âºè');
                    }
                };

                // È¢ùÂ§ñÁöÑÁÇπÂáªÂ§ÑÁêÜ - Â§áÁî®ÊñπÊ°à
                this.canvas.addEventListener('click', (event) => {
                    console.log('CanvasÁÇπÂáª‰∫ã‰ª∂Ëß¶Âèë');
                    
                    // ÂàõÂª∫ÊãæÂèñÂ∞ÑÁ∫ø
                    const pickRay = this.scene.createPickingRay(
                        this.scene.pointerX, 
                        this.scene.pointerY, 
                        BABYLON.Matrix.Identity(), 
                        this.camera
                    );
                    
                    // ÊâãÂä®ÊâßË°åÊãæÂèñ
                    const pickInfo = this.scene.pickWithRay(pickRay, (mesh) => {
                        // Âè™ÊãæÂèñÁªÑ‰ª∂ÁΩëÊ†º
                        return this.components.some(comp => comp.mesh === mesh);
                    });
                    
                    console.log('ÊâãÂä®ÊãæÂèñÁªìÊûú:', pickInfo);
                    
                    if (pickInfo && pickInfo.hit) {
                        const component = this.components.find(comp => comp.mesh === pickInfo.pickedMesh);
                        if (component) {
                            console.log('ÊâãÂä®ÊãæÂèñÊâæÂà∞ÁªÑ‰ª∂:', component.type);
                            this.selectComponent(component);
                        }
                    }
                });

                // UI‰∫ã‰ª∂
                this.setupUIEventListeners();

                // ÂÆûÊó∂È´òÊÄßËÉΩÊõ¥Êñ∞ - ÁßªÈô§ÊâÄÊúâÈôêÂà∂
                this.scene.onBeforeRenderObservable.add(() => {
                    const currentTime = Date.now();
                    
                    // ÂÆûÊó∂ÂÖâÁ∫øËøΩË∏™Êõ¥Êñ∞ÔºàÁßªÈô§Êó∂Èó¥ÈôêÂà∂Ôºâ
                    if (this.enableRealtimeRayTracing && this.needsRayUpdate) {
                        this.updateRayTracing();
                        this.lastRayUpdateTime = currentTime;
                        this.needsRayUpdate = false;
                    }
                    
                    // È´òÈ¢ëÁéáÁ≥ªÁªü‰ø°ÊÅØÊõ¥Êñ∞ÔºàÊØèÂ∏ßÊõ¥Êñ∞Ôºâ
                    this.updateSystemInfo();
                });

                // È¢ùÂ§ñÁöÑÊ∏≤ÊüìÂêéÂ§ÑÁêÜ
                this.scene.onAfterRenderObservable.add(() => {
                    // Âº∫Âà∂ÊùêË¥®Êõ¥Êñ∞ÔºàÂèØÈÄâÔºåÊ∂àËÄóÊÄßËÉΩ‰ΩÜÁ°Æ‰øùÂÆûÊó∂ÊïàÊûúÔºâ
                    if (this.forceRender && this.components.length > 0) {
                        this.scene.markAllMaterialsAsDirty(BABYLON.Material.AllDirtyFlag);
                    }
                });

                // ÂÆûÊó∂GizmoÊãñÊãΩÁõëÂê¨
                if (this.gizmoManager) {
                    this.scene.onPointerObservable.add((pointerInfo) => {
                        if (pointerInfo.pickInfo?.hit && this.selectedComponent) {
                            // ÂÆûÊó∂Êõ¥Êñ∞ÂÖâÁ∫øËøΩË∏™
                            this.needsRayUpdate = true;
                        }
                    });
                }

                // Á™óÂè£Ë∞ÉÊï¥
                window.addEventListener('resize', () => {
                    if (this.engine) {
                        this.engine.resize();
                    }
                });
                
                console.log('‰∫ã‰ª∂ÁõëÂê¨Âô®ËÆæÁΩÆÂÆåÊàê - ÂÆûÊó∂È´òÊÄßËÉΩÊ®°ÂºèÂ∑≤ÂêØÁî®');
            }

            // Ëé∑ÂèñÈº†Ê†áÂú®Âú∞Èù¢‰∏äÁöÑÊãæÂèñÁÇπ
            getGroundPickPoint(evt) {
                try {
                    const ray = this.scene.createPickingRay(this.scene.pointerX, this.scene.pointerY, BABYLON.Matrix.Identity(), this.camera);
                    const groundPlane = new BABYLON.Plane(0, 1, 0, 0); // Y=0Âπ≥Èù¢
                    const distance = ray.intersectsPlane(groundPlane);
                    
                    if (distance !== null) {
                        return ray.origin.add(ray.direction.scale(distance));
                    }
                    return null;
                } catch (error) {
                    console.error('Ëé∑ÂèñÊãæÂèñÁÇπÂ§±Ë¥•:', error);
                    return null;
                }
            }

            setupUIEventListeners() {
                const componentButtons = document.querySelectorAll('.component-btn');
                componentButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const type = btn.dataset.type;
                        const subtype = btn.dataset.subtype;
                        this.addComponent(type, subtype);
                        
                        componentButtons.forEach(b => b.classList.remove('selected'));
                        btn.classList.add('selected');

                        setTimeout(() => {
                            btn.classList.remove('selected');
                        }, 2000);
                    });
                });
                
                // ÊÄßËÉΩÊéßÂà∂Èù¢Êùø‰∫ã‰ª∂ÁõëÂê¨Âô®
                this.setupPerformanceControls();
                
                console.log('UI‰∫ã‰ª∂ÁõëÂê¨Âô®ËÆæÁΩÆÂÆåÊàê');
            }

            setupPerformanceControls() {
                // ÂÆûÊó∂ÂÖâÁ∫øËøΩË∏™ÊéßÂà∂
                const realtimeRayTracingCheckbox = document.getElementById('realtimeRayTracing');
                if (realtimeRayTracingCheckbox) {
                    realtimeRayTracingCheckbox.addEventListener('change', (e) => {
                        this.enableRealtimeRayTracing = e.target.checked;
                        this.needsRayUpdate = true;
                        console.log('ÂÆûÊó∂ÂÖâÁ∫øËøΩË∏™:', this.enableRealtimeRayTracing ? 'ÂêØÁî®' : 'Á¶ÅÁî®');
                    });
                }

                // Âº∫Âà∂Ê∏≤ÊüìÊéßÂà∂
                const forceRenderCheckbox = document.getElementById('forceRender');
                if (forceRenderCheckbox) {
                    forceRenderCheckbox.addEventListener('change', (e) => {
                        this.forceRender = e.target.checked;
                        console.log('Âº∫Âà∂ÊØèÂ∏ßÊ∏≤Êüì:', this.forceRender ? 'ÂêØÁî®' : 'Á¶ÅÁî®');
                    });
                }

                // È´òÁ∫ßÂÖâÁ∫øËøΩË∏™ÊéßÂà∂
                const advancedRayTracingCheckbox = document.getElementById('advancedRayTracing');
                if (advancedRayTracingCheckbox) {
                    advancedRayTracingCheckbox.addEventListener('change', (e) => {
                        this.enableAdvancedRayTracing = e.target.checked;
                        this.needsRayUpdate = true;
                        console.log('È´òÁ∫ßÂÖâÁ∫øËøΩË∏™:', this.enableAdvancedRayTracing ? 'ÂêØÁî®' : 'Á¶ÅÁî®');
                    });
                }

                // ÂÖâÁ∫øÂØÜÂ∫¶ÊéßÂà∂
                const rayDensitySlider = document.getElementById('rayDensity');
                const rayDensityValue = document.getElementById('rayDensityValue');
                if (rayDensitySlider && rayDensityValue) {
                    rayDensitySlider.addEventListener('input', (e) => {
                        this.rayDensity = parseInt(e.target.value);
                        rayDensityValue.textContent = this.rayDensity;
                        this.needsRayUpdate = true;
                        console.log('ÂÖâÁ∫øÂØÜÂ∫¶ËÆæÁΩÆ‰∏∫:', this.rayDensity);
                    });
                }

                // ÊúÄÂ§ßÂèçÂºπÊ¨°Êï∞ÊéßÂà∂
                const maxBouncesSlider = document.getElementById('maxBounces');
                const maxBouncesValue = document.getElementById('maxBouncesValue');
                if (maxBouncesSlider && maxBouncesValue) {
                    maxBouncesSlider.addEventListener('input', (e) => {
                        this.maxBounces = parseInt(e.target.value);
                        maxBouncesValue.textContent = this.maxBounces;
                        this.needsRayUpdate = true;
                        console.log('ÊúÄÂ§ßÂèçÂºπÊ¨°Êï∞ËÆæÁΩÆ‰∏∫:', this.maxBounces);
                    });
                }
                
                // ÊúÄÂ§ßGPUË¥üËΩΩÊéßÂà∂
                const maxGpuLoadCheckbox = document.getElementById('maxGpuLoad');
                if (maxGpuLoadCheckbox) {
                    maxGpuLoadCheckbox.addEventListener('change', (e) => {
                        this.maxGpuLoad = e.target.checked;
                        if (this.maxGpuLoad) {
                            this.enableGpuStressMode();
                        } else {
                            this.disableGpuStressMode();
                        }
                        console.log('ÊúÄÂ§ßGPUË¥üËΩΩ:', this.maxGpuLoad ? 'ÂêØÁî®' : 'Á¶ÅÁî®');
                    });
                }
                
                // Ê∏≤ÊüìÂàÜËæ®ÁéáÊéßÂà∂
                const renderScaleSlider = document.getElementById('renderScale');
                const renderScaleValue = document.getElementById('renderScaleValue');
                if (renderScaleSlider && renderScaleValue) {
                    renderScaleSlider.addEventListener('input', (e) => {
                        const scale = parseInt(e.target.value);
                        renderScaleValue.textContent = scale + '%';
                        this.updateRenderResolution(scale / 100);
                        console.log('Ê∏≤ÊüìÂàÜËæ®ÁéáËÆæÁΩÆ‰∏∫:', scale + '%');
                    });
                }
                
                // ÁõÆÊ†áFPSÊéßÂà∂
                const targetFpsSlider = document.getElementById('targetFps');
                const targetFpsValue = document.getElementById('targetFpsValue');
                if (targetFpsSlider && targetFpsValue) {
                    targetFpsSlider.addEventListener('input', (e) => {
                        this.targetFPS = parseInt(e.target.value);
                        targetFpsValue.textContent = this.targetFPS;
                        console.log('ÁõÆÊ†áFPSËÆæÁΩÆ‰∏∫:', this.targetFPS);
                    });
                }
                
                // GPUÂéãÂäõÊµãËØïÊåâÈíÆ
                const forceGpuStressBtn = document.getElementById('forceGpuStress');
                if (forceGpuStressBtn) {
                    forceGpuStressBtn.addEventListener('click', () => {
                        this.startGpuStressTest();
                    });
                }
                
                // ÂÜÖÂ≠ò‰ºòÂåñÊåâÈíÆ
                const optimizeMemoryBtn = document.getElementById('optimizeMemory');
                if (optimizeMemoryBtn) {
                    optimizeMemoryBtn.addEventListener('click', () => {
                        this.optimizeMemoryUsage();
                    });
                }
                
                console.log('üî• ÊûÅÈôêÊÄßËÉΩÊéßÂà∂Èù¢ÊùøËÆæÁΩÆÂÆåÊàê');
            }
            
            // ÂêØÁî®GPUÂéãÂäõÊ®°Âºè
            enableGpuStressMode() {
                console.log('üî• ÂêØÁî®GPUÂéãÂäõÊ®°Âºè...');
                this.createAdditionalGpuLoad();
                // Â¢ûÂä†ÂÖâÁ∫øËøΩË∏™Â§çÊùÇÂ∫¶
                this.rayDensity = Math.min(this.rayDensity * 2, 10);
                this.maxBounces = Math.min(this.maxBounces * 1.5, 200);
                this.needsRayUpdate = true;
            }
            
            // Á¶ÅÁî®GPUÂéãÂäõÊ®°Âºè
            disableGpuStressMode() {
                console.log('üßä Á¶ÅÁî®GPUÂéãÂäõÊ®°Âºè...');
                this.removeAdditionalGpuLoad();
            }
            
            // ÂàõÂª∫È¢ùÂ§ñGPUË¥üËΩΩ
            createAdditionalGpuLoad() {
                if (this.gpuStressObjects) return;
                
                this.gpuStressObjects = [];
                for (let i = 0; i < 50; i++) {
                    const torus = BABYLON.MeshBuilder.CreateTorus(`stressTest${i}`, {
                        diameter: 0.5,
                        thickness: 0.1,
                        tessellation: 32
                    }, this.scene);
                    
                    torus.position = new BABYLON.Vector3(
                        (Math.random() - 0.5) * 100,
                        (Math.random() - 0.5) * 100,
                        (Math.random() - 0.5) * 100
                    );
                    
                    torus.isVisible = false; // ÈöêËóè‰ΩÜÂèÇ‰∏éËÆ°ÁÆó
                    this.gpuStressObjects.push(torus);
                }
                console.log(`‚úÖ Â∑≤ÂàõÂª∫ ${this.gpuStressObjects.length} ‰∏™GPUÂéãÂäõÊµãËØïÂØπË±°`);
            }
            
            // ÁßªÈô§È¢ùÂ§ñGPUË¥üËΩΩ
            removeAdditionalGpuLoad() {
                if (this.gpuStressObjects) {
                    this.gpuStressObjects.forEach(obj => obj.dispose());
                    this.gpuStressObjects = null;
                    console.log('üóëÔ∏è Â∑≤ÁßªÈô§GPUÂéãÂäõÊµãËØïÂØπË±°');
                }
            }
            
            // Êõ¥Êñ∞Ê∏≤ÊüìÂàÜËæ®Áéá
            updateRenderResolution(scale) {
                const baseWidth = window.innerWidth;
                const baseHeight = window.innerHeight;
                const newWidth = Math.floor(baseWidth * scale);
                const newHeight = Math.floor(baseHeight * scale);
                
                this.engine.setSize(newWidth, newHeight, false);
                console.log(`üñ•Ô∏è Ê∏≤ÊüìÂàÜËæ®ÁéáÊõ¥Êñ∞‰∏∫: ${newWidth}x${newHeight} (${Math.round(scale * 100)}%)`);
            }
            
            // ÂºÄÂßãGPUÂéãÂäõÊµãËØï
            startGpuStressTest() {
                console.log('üî• ÂºÄÂßãGPUÂéãÂäõÊµãËØï...');
                
                // ‰∏¥Êó∂ÂàõÂª∫Â§ßÈáèÂ§çÊùÇÂØπË±°
                const stressObjects = [];
                for (let i = 0; i < 100; i++) {
                    const sphere = BABYLON.MeshBuilder.CreateSphere(`gpuStress${i}`, {
                        diameter: 1,
                        segments: 64 // È´òÁªÜÂàÜ
                    }, this.scene);
                    
                    sphere.position = new BABYLON.Vector3(
                        (Math.random() - 0.5) * 50,
                        (Math.random() - 0.5) * 50,
                        (Math.random() - 0.5) * 50
                    );
                    
                    // Â§çÊùÇÊùêË¥®
                    const mat = new BABYLON.StandardMaterial(`stressMat${i}`, this.scene);
                    mat.diffuseColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random());
                    mat.specularPower = 128;
                    sphere.material = mat;
                    
                    sphere.isVisible = false;
                    stressObjects.push(sphere);
                }
                
                // 10ÁßíÂêéÊ∏ÖÁêÜ
                setTimeout(() => {
                    stressObjects.forEach(obj => obj.dispose());
                    console.log('üßπ GPUÂéãÂäõÊµãËØïÁªìÊùüÔºåÂ∑≤Ê∏ÖÁêÜÊµãËØïÂØπË±°');
                }, 10000);
                
                console.log(`üöÄ GPUÂéãÂäõÊµãËØïËøõË°å‰∏≠... (${stressObjects.length} ‰∏™ÂØπË±°Ôºå10ÁßíÂêéËá™Âä®Ê∏ÖÁêÜ)`);
            }
            
            // ‰ºòÂåñÂÜÖÂ≠ò‰ΩøÁî®
            optimizeMemoryUsage() {
                console.log('üßπ ÂºÄÂßãÂÜÖÂ≠ò‰ºòÂåñ...');
                
                // Ê∏ÖÁêÜÁºìÂ≠ò
                this.scene.cleanCachedTextureBuffer();
                
                // Âº∫Âà∂ÂûÉÂúæÂõûÊî∂
                if (window.gc) {
                    window.gc();
                    console.log('‚úÖ Â∑≤ÊâßË°åÂº∫Âà∂ÂûÉÂúæÂõûÊî∂');
                }
                
                // ‰ºòÂåñÁΩëÊ†º
                this.scene.meshes.forEach(mesh => {
                    if (mesh.geometry) {
                        mesh.refreshBoundingInfo();
                    }
                });
                
                console.log('‚úÖ ÂÜÖÂ≠ò‰ºòÂåñÂÆåÊàê');
            }

            addComponent(type, subtype = null) {
                try {
                    let mesh;
                    const position = new BABYLON.Vector3(
                        (Math.random() - 0.5) * 10,
                        1,
                        (Math.random() - 0.5) * 8
                    );

                    const properties = this.getDefaultProperties(type, subtype);

                    switch (type) {
                        case 'laser':
                            mesh = this.createLaser(position, properties);
                            break;
                        case 'lens':
                            mesh = this.createLens(subtype, position, properties);
                            break;
                        case 'mirror':
                            mesh = this.createMirror(subtype, position, properties);
                            break;
                        case 'prism':
                            mesh = this.createPrism(position, properties);
                            break;
                        case 'grating':
                            mesh = this.createGrating(position, properties);
                            break;
                        case 'screen':
                            mesh = this.createScreen(position, properties);
                            break;
                    }

                    if (mesh) {
                        const component = {
                            mesh: mesh,
                            type: type,
                            subtype: subtype,
                            properties: properties,
                            id: 'comp_' + Date.now()
                        };

                        mesh.metadata = {
                            type: this.getOpticalType(type, subtype),
                            ior: properties.ior || 1.0,
                            component: component
                        };

                        this.components.push(component);
                        
                        console.log(`ÁªÑ‰ª∂ÂàõÂª∫ÊàêÂäü: ${type}, ÊÄªÊï∞: ${this.components.length}`);
                        console.log('Êñ∞ÂàõÂª∫ÁöÑÁΩëÊ†º:', mesh.name, 'ÂèØÊãæÂèñ:', mesh.isPickable);
                        console.log('ÁªÑ‰ª∂ÂàóË°®:', this.components.map(c => `${c.type}(${c.mesh.name})`));
                        
                        this.selectComponent(component);
                        this.needsRayUpdate = true;
                    }
                } catch (error) {
                    console.error('ÁªÑ‰ª∂ÂàõÂª∫Â§±Ë¥•:', error);
                }
            }

            getOpticalType(type, subtype) {
                switch (type) {
                    case 'laser':
                        return 'source';
                    case 'lens':
                    case 'prism':
                        return 'refractive';
                    case 'mirror':
                        return 'reflective';
                    case 'grating':
                        return 'diffractive';
                    case 'screen':
                        return 'absorptive';
                    default:
                        return 'unknown';
                }
            }

            createLaser(position, properties) {
                const mesh = BABYLON.MeshBuilder.CreateCylinder("laser", {
                    height: 1,
                    diameter: 0.5
                }, this.scene);
                
                mesh.position = position;
                mesh.rotation.z = Math.PI / 2;
                
                // Á°Æ‰øùmeshÂèØ‰ª•Ë¢´ÊãæÂèñ
                mesh.isPickable = true;
                
                const material = new BABYLON.StandardMaterial("laserMat", this.scene);
                material.diffuseColor = this.hexToColor3(properties.color || "#ff0000");
                material.emissiveColor = material.diffuseColor.scale(0.3);
                mesh.material = material;
                
                return mesh;
            }

            // ÂàõÂª∫ÈÄèÈïúÂΩ¢Áä∂ÔºàÊ†πÊçÆÈÄèÈïúÂà∂ÈÄ†ËÄÖÂÖ¨ÂºèÂíåÂÖâÂ≠¶ÂéüÁêÜÔºâ
            createLens(subtype, position, properties) {
                let mesh;
                const focalLength = properties.focalLength || 50;
                const diameter = properties.diameter || 25;
                const ior = properties.ior || 1.5;
                const userThickness = properties.thickness || null;
                const isConvex = focalLength > 0;
                
                // ËÆ°ÁÆóÈÄèÈïúÂèÇÊï∞
                const R = 2 * Math.abs(focalLength) * (ior - 1);
                const sagitta = Math.pow(diameter/2, 2) / (2 * R);
                const minThickness = Math.max(0.5, diameter * 0.02);
                const maxThickness = diameter * 0.6;
                
                let centerThickness;
                if (userThickness !== null && userThickness > 0) {
                    centerThickness = Math.max(minThickness, Math.min(maxThickness, userThickness));
                } else {
                    if (focalLength > 0) {
                        centerThickness = Math.max(minThickness, Math.min(maxThickness, sagitta * 2 + minThickness));
                    } else {
                        centerThickness = Math.max(minThickness, maxThickness - sagitta * 1.5);
                    }
                }
                
                if (isConvex) {
                    mesh = this.createConvexLens(diameter, centerThickness, R);
                } else {
                    mesh = this.createConcaveLens(diameter, centerThickness, R);
                }
                
                mesh.position = position;
                mesh.rotation.z = Math.PI / 2;
                
                // Á°Æ‰øùmeshÂèØ‰ª•Ë¢´ÊãæÂèñ
                mesh.isPickable = true;
                
                const material = new BABYLON.StandardMaterial("lensMat", this.scene);
                material.diffuseColor = this.hexToColor3(properties.color || "#80c0ff");
                material.alpha = properties.transparency || 0.6;
                material.specularColor = new BABYLON.Color3(1, 1, 1);
                material.specularPower = 64;
                mesh.material = material;
                
                return mesh;
            }
            
            // ÂàõÂª∫Âá∏ÈÄèÈïúÂá†‰Ωï‰Ωì
            createConvexLens(diameter, centerThickness, radiusOfCurvature) {
                // ‰ΩøÁî®ÁêÉ‰ΩìÂàõÂª∫Âá∏ÈÄèÈïúÔºåÁÑ∂ÂêéÊâÅÂπ≥Âåñ
                const lens = BABYLON.MeshBuilder.CreateSphere("convexLens", {
                    diameter: diameter / 10,
                    segments: 32
                }, this.scene);
                
                // ËÆ°ÁÆóÂéöÂ∫¶ÊØî‰æã
                const thicknessRatio = Math.max(0.1, Math.min(0.8, centerThickness / diameter));
                
                // ÊâÅÂπ≥ÂåñÂΩ¢ÊàêÈÄèÈïúÂΩ¢Áä∂
                lens.scaling.x = thicknessRatio;
                
                // Á°Æ‰øùmeshÂèØ‰ª•Ë¢´ÊãæÂèñ
                lens.isPickable = true;
                
                return lens;
            }
            
            // ÂàõÂª∫ÂáπÈÄèÈïúÂá†‰Ωï‰Ωì
            createConcaveLens(diameter, centerThickness, radiusOfCurvature) {
                // ‰ΩøÁî®ÂúÜÊü±‰ΩìÂàõÂª∫ÂáπÈÄèÈïúÂü∫Á°Ä
                const edgeThickness = Math.max(centerThickness * 1.5, diameter * 0.05);
                const lens = BABYLON.MeshBuilder.CreateCylinder("concaveLens", {
                    diameter: diameter / 10,
                    height: edgeThickness / 10,
                    tessellation: 32
                }, this.scene);
                
                // ÂàõÂª∫‰∏≠ÂøÉÂáπÈô∑ÊïàÊûú
                const positions = lens.getVerticesData(BABYLON.VertexBuffer.PositionKind);
                if (positions) {
                    for (let i = 0; i < positions.length; i += 3) {
                        const x = positions[i];
                        const y = positions[i + 1];
                        const z = positions[i + 2];
                        
                        // ËÆ°ÁÆóË∑ùÁ¶ª‰∏≠ÂøÉÁöÑÂæÑÂêëË∑ùÁ¶ª
                        const radialDistance = Math.sqrt(y * y + z * z);
                        const maxRadius = diameter / 20;
                        
                        if (radialDistance < maxRadius) {
                            // Âú®‰∏≠ÂøÉÂå∫ÂüüÂàõÂª∫ÂáπÈô∑
                            const normalizedRadius = radialDistance / maxRadius;
                            const depression = (1 - normalizedRadius * normalizedRadius) * 0.5;
                            positions[i] = x * (1 - depression);
                        }
                    }
                    lens.setVerticesData(BABYLON.VertexBuffer.PositionKind, positions);
                }
                
                // Á°Æ‰øùmeshÂèØ‰ª•Ë¢´ÊãæÂèñ
                lens.isPickable = true;
                
                return lens;
            }

            createMirror(subtype, position, properties) {
                let mesh;
                
                if (subtype === 'plane') {
                    mesh = BABYLON.MeshBuilder.CreateBox("mirror", {
                        width: properties.width / 10, 
                        height: properties.height / 10, 
                        depth: properties.thickness / 100
                    }, this.scene);
                } else {
                    // ÂáπÈù¢Èïú‰ΩøÁî®ÈÉ®ÂàÜÁêÉ‰Ωì
                    mesh = BABYLON.MeshBuilder.CreateSphere("concaveMirror", {
                        diameter: properties.diameter / 10,
                        segments: 32,
                        arc: 0.5
                    }, this.scene);
                    mesh.scaling = new BABYLON.Vector3(0.2, 1, 1);
                }
                
                mesh.position = position;
                if (subtype === 'plane') {
                    mesh.rotation.y = -Math.PI / 4;
                }
                
                // Á°Æ‰øùmeshÂèØ‰ª•Ë¢´ÊãæÂèñ
                mesh.isPickable = true;
                
                const material = new BABYLON.StandardMaterial("mirrorMat", this.scene);
                material.diffuseColor = this.hexToColor3(properties.color || "#c0c0c0");
                material.specularColor = new BABYLON.Color3(0.9, 0.9, 0.9);
                material.specularPower = 128;
                material.reflectionTexture = new BABYLON.MirrorTexture("mirrorTexture", 512, this.scene);
                material.reflectionTexture.mirrorPlane = new BABYLON.Plane(0, 0, -1, 0);
                mesh.material = material;
                
                return mesh;
            }

            createPrism(position, properties) {
                const mesh = BABYLON.MeshBuilder.CreateCylinder("prism", {
                    diameter: properties.size / 10,
                    height: properties.height / 10,
                    tessellation: 3
                }, this.scene);
                
                mesh.position = position;
                mesh.rotation.x = Math.PI / 2;
                mesh.rotation.y = (properties.rotation || 0) * Math.PI / 180;
                
                // Á°Æ‰øùmeshÂèØ‰ª•Ë¢´ÊãæÂèñ
                mesh.isPickable = true;
                
                const material = new BABYLON.StandardMaterial("prismMat", this.scene);
                material.diffuseColor = this.hexToColor3(properties.color || "#f0f0f5");
                material.alpha = properties.transparency || 0.7;
                material.specularColor = new BABYLON.Color3(1, 1, 1);
                mesh.material = material;
                
                return mesh;
            }

            createGrating(position, properties) {
                // ÂàõÂª∫ÁÆÄÂåñÁöÑÂÖâÊ†Ö
                const mesh = BABYLON.MeshBuilder.CreatePlane("grating", {
                    size: properties.size / 10
                }, this.scene);
                
                mesh.position = position;
                
                // Á°Æ‰øùmeshÂèØ‰ª•Ë¢´ÊãæÂèñ
                mesh.isPickable = true;
                
                const material = new BABYLON.StandardMaterial("gratingMat", this.scene);
                material.diffuseColor = this.hexToColor3(properties.color || "#808080");
                material.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                
                // ÂàõÂª∫ÂÖâÊ†ÖÁ∫πÁêÜ
                const texture = new BABYLON.DynamicTexture("gratingTexture", {width: 512, height: 512}, this.scene);
                const ctx = texture.getContext();
                
                // ÁªòÂà∂ÂÖâÊ†ÖÁ∫øÊù°
                ctx.fillStyle = "#808080";
                ctx.fillRect(0, 0, 512, 512);
                
                const lineCount = Math.min(50, properties.linesPerMM / 10);
                const lineWidth = 512 / lineCount;
                
                ctx.fillStyle = "#404040";
                for (let i = 0; i < lineCount; i += 2) {
                    ctx.fillRect(i * lineWidth, 0, lineWidth / 2, 512);
                }
                
                texture.update();
                material.diffuseTexture = texture;
                mesh.material = material;
                
                return mesh;
            }

            createScreen(position, properties) {
                const mesh = BABYLON.MeshBuilder.CreatePlane("screen", {
                    width: properties.width / 10,
                    height: properties.height / 10
                }, this.scene);
                
                mesh.position = position;
                
                // Á°Æ‰øùmeshÂèØ‰ª•Ë¢´ÊãæÂèñ
                mesh.isPickable = true;
                
                const material = new BABYLON.StandardMaterial("screenMat", this.scene);
                material.diffuseColor = this.hexToColor3(properties.color || "#ffffff");
                material.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                mesh.material = material;
                
                return mesh;
            }

            getDefaultProperties(type, subtype) {
                const defaults = {
                    laser: {
                        wavelength: 632.8,
                        power: 5,
                        beamDiameter: 1,
                        color: "#ff0000",
                        divergence: 0.1
                    },
                    lens: {
                        ior: 1.5,
                        focalLength: 50,
                        diameter: 25,
                        thickness: 5,
                        color: "#80c0ff",
                        transparency: 0.6
                    },
                    mirror: {
                        reflectivity: 0.95,
                        curvature: subtype === 'plane' ? 0 : 100,
                        width: 25,
                        height: 25,
                        thickness: 3,
                        diameter: 25,
                        color: "#c0c0c0"
                    },
                    prism: {
                        ior: 1.6,
                        apexAngle: 60,
                        size: 15,
                        height: 15,
                        rotation: 0,
                        color: "#f0f0f5",
                        transparency: 0.7
                    },
                    grating: {
                        linesPerMM: 500,
                        efficiency: 0.8,
                        size: 20,
                        blazeAngle: 0,
                        color: "#808080"
                    },
                    screen: {
                        width: 30,
                        height: 30,
                        color: "#ffffff"
                    }
                };

                return defaults[type] || {};
            }

            hexToColor3(hex) {
                const r = parseInt(hex.slice(1, 3), 16) / 255;
                const g = parseInt(hex.slice(3, 5), 16) / 255;
                const b = parseInt(hex.slice(5, 7), 16) / 255;
                return new BABYLON.Color3(r, g, b);
            }

            color3ToHex(color3) {
                const r = Math.round(color3.r * 255).toString(16).padStart(2, '0');
                const g = Math.round(color3.g * 255).toString(16).padStart(2, '0');
                const b = Math.round(color3.b * 255).toString(16).padStart(2, '0');
                return `#${r}${g}${b}`;
            }

            selectComponent(component) {
                console.log('ÂºÄÂßãÈÄâÊã©ÁªÑ‰ª∂:', component.type);
                this.clearSelection();
                
                this.selectedComponent = component;
                
                if (this.gizmoManager) {
                    console.log('GizmoManagerÂèØÁî®ÔºåËÆæÁΩÆGizmoÊ®°Âºè:', this.transformMode);
                    
                    try {
                        // Ê†πÊçÆÂΩìÂâçÂèòÊç¢Ê®°ÂºèËÆæÁΩÆGizmo
                        this.setTransformMode(this.transformMode);
                        
                        console.log('ÈôÑÂä†GizmoÂà∞ÁªÑ‰ª∂');
                        this.gizmoManager.attachToMesh(component.mesh);
                        
                        // È™åËØÅGizmoÊòØÂê¶Ê≠£Á°ÆÈôÑÂä†
                        if (this.gizmoManager.attachedMesh === component.mesh) {
                            console.log('GizmoÊàêÂäüÈôÑÂä†Âà∞ÁªÑ‰ª∂');
                        } else {
                            console.warn('GizmoÈôÑÂä†ÂèØËÉΩÂ§±Ë¥•');
                        }
                    } catch (error) {
                        console.error('GizmoÊìç‰ΩúÂ§±Ë¥•:', error);
                    }
                } else {
                    console.warn('GizmoManager ‰∏çÂèØÁî®');
                }
                
                this.updatePropertiesPanel();
                
                // Ê∑ªÂä†È´ò‰∫ÆÊïàÊûú
                if (component.mesh.material) {
                    component.originalEmissive = component.mesh.material.emissiveColor.clone();
                    component.mesh.material.emissiveColor = new BABYLON.Color3(0, 0.2, 0.4);
                }
                
                console.log(`ÈÄâ‰∏≠ÁªÑ‰ª∂: ${component.type} (${this.transformMode}Ê®°Âºè)`);
            }

            clearSelection() {
                if (this.selectedComponent) {
                    // ÊÅ¢Â§çÂéüÂßãÂèëÂÖâÈ¢úËâ≤
                    if (this.selectedComponent.mesh.material && this.selectedComponent.originalEmissive) {
                        this.selectedComponent.mesh.material.emissiveColor = this.selectedComponent.originalEmissive;
                    }
                    
                    if (this.gizmoManager) {
                        this.gizmoManager.attachToMesh(null);
                    }
                    
                    this.selectedComponent = null;
                    
                    // Ê∏ÖÁêÜÂõûË∞ÉÂáΩÊï∞
                    if (window.sliderCallbacks) {
                        window.sliderCallbacks = {};
                    }
                    if (window.colorCallbacks) {
                        window.colorCallbacks = {};
                    }
                    
                    const panel = document.getElementById('propertyControls');
                    if (panel) {
                        panel.innerHTML = '<p>ÈÄâÊã©‰∏Ä‰∏™ÁªÑ‰ª∂Êù•ÁºñËæëÂ±ûÊÄß</p>';
                    }
                }
            }

            updatePropertiesPanel() {
                if (!this.selectedComponent) return;
                
                const panel = document.getElementById('propertyControls');
                const component = this.selectedComponent;
                const mesh = component.mesh;
                const pos = mesh.position;
                const rot = mesh.rotation;
                
                let html = `<div style="margin-bottom: 10px;"><strong>ID:</strong> ${component.id}</div>`;
                
                // ÁâπÊÆäÂ§ÑÁêÜÈÄèÈïúÁ±ªÂûãÊòæÁ§∫
                let typeDisplay = component.type;
                if (component.type === 'lens') {
                    const focalLength = component.properties.focalLength || 50;
                    typeDisplay = focalLength > 0 ? 'Âá∏ÈÄèÈïú' : 'ÂáπÈÄèÈïú';
                } else if (component.subtype) {
                    typeDisplay += ' - ' + component.subtype;
                }
                
                html += `<div style="margin-bottom: 10px;"><strong>Á±ªÂûã:</strong> ${typeDisplay}</div>`;
                html += `<div style="margin-bottom: 15px; padding: 8px; background: rgba(0, 150, 255, 0.2); border-radius: 4px; border: 1px solid #0099ff;">
                    <strong>ÂèòÊç¢Ê®°Âºè:</strong> ${this.transformMode === 'translate' ? 'ÁßªÂä® (ÊåâTÈîÆ)' : 'ÊóãËΩ¨ (ÊåâRÈîÆ)'}
                </div>`;
                
                // ‰ΩçÁΩÆÊéßÂà∂
                html += this.createSlider("‰ΩçÁΩÆ X", pos.x, -10, 10, 0.1, (val) => {
                    mesh.position.x = val;
                    this.needsRayUpdate = true;
                });
                html += this.createSlider("‰ΩçÁΩÆ Y", pos.y, 0, 10, 0.1, (val) => {
                    mesh.position.y = val;
                    this.needsRayUpdate = true;
                });
                html += this.createSlider("‰ΩçÁΩÆ Z", pos.z, -10, 10, 0.1, (val) => {
                    mesh.position.z = val;
                    this.needsRayUpdate = true;
                });
                
                // ÊóãËΩ¨ÊéßÂà∂
                html += this.createSlider("ÊóãËΩ¨ X", rot.x * 180 / Math.PI, -180, 180, 1, (val) => {
                    mesh.rotation.x = val * Math.PI / 180;
                    this.needsRayUpdate = true;
                });
                html += this.createSlider("ÊóãËΩ¨ Y", rot.y * 180 / Math.PI, -180, 180, 1, (val) => {
                    mesh.rotation.y = val * Math.PI / 180;
                    this.needsRayUpdate = true;
                });
                html += this.createSlider("ÊóãËΩ¨ Z", rot.z * 180 / Math.PI, -180, 180, 1, (val) => {
                    mesh.rotation.z = val * Math.PI / 180;
                    this.needsRayUpdate = true;
                });
                
                // ÁªÑ‰ª∂ÁâπÂÆöÂ±ûÊÄß
                html = this.addComponentSpecificProperties(html, component);
                
                // Âà†Èô§ÊåâÈíÆ
                html += `<div class="property-group">
                    <button onclick="opticalSystemGame.removeSelectedComponent()">Âà†Èô§ÁªÑ‰ª∂</button>
                </div>`;
                
                panel.innerHTML = html;
                
                // Ê∑ªÂä†ÊªëÂùóÂíåÈ¢úËâ≤ÈÄâÊã©Âô®‰∫ã‰ª∂
                this.setupSliderEvents();
                this.setupColorEvents();
            }

            addComponentSpecificProperties(html, component) {
                const props = component.properties;
                
                switch (component.type) {
                    case 'laser':
                        html += this.createSlider("Ê≥¢Èïø (nm)", props.wavelength, 400, 700, 1, (val) => {
                            props.wavelength = val;
                            this.updateLaserColor(component, val);
                            this.needsRayUpdate = true;
                        });
                        html += this.createSlider("ÂäüÁéá (mW)", props.power, 1, 100, 1, (val) => {
                            props.power = val;
                        });
                        html += this.createSlider("ÂÖâÊùüÁõ¥ÂæÑ", props.beamDiameter, 0.5, 5, 0.1, (val) => {
                            props.beamDiameter = val;
                            this.needsRayUpdate = true;
                        });
                        html += this.createColorPicker("È¢úËâ≤", props.color, (val) => {
                            props.color = val;
                            this.updateMeshColor(component.mesh, val);
                        });
                        break;
                        
                    case 'lens':
                        html += this.createSlider("ÊäòÂ∞ÑÁéá", props.ior, 1.0, 2.5, 0.01, (val) => {
                            props.ior = val;
                            component.mesh.metadata.ior = val;
                            this.updateLensShape(component);
                            this.needsRayUpdate = true;
                        });
                        html += this.createSlider("ÁÑ¶Ë∑ù (mm)", props.focalLength, -200, 200, 1, (val) => {
                            props.focalLength = val;
                            this.updateLensShape(component);
                            this.needsRayUpdate = true;
                        });
                        html += this.createSlider("Áõ¥ÂæÑ (mm)", props.diameter, 10, 50, 1, (val) => {
                            props.diameter = val;
                            this.updateLensShape(component);
                            this.needsRayUpdate = true;
                        });
                        html += this.createSlider("‰∏≠ÂøÉÂéöÂ∫¶ (mm)", props.thickness, 0.5, 15, 0.1, (val) => {
                            props.thickness = val;
                            this.updateLensShape(component);
                            this.needsRayUpdate = true;
                        });
                        html += this.createSlider("ÈÄèÊòéÂ∫¶", props.transparency, 0.1, 1.0, 0.05, (val) => {
                            props.transparency = val;
                            if (component.mesh.material) {
                                component.mesh.material.alpha = val;
                            }
                        });
                        html += this.createColorPicker("È¢úËâ≤", props.color, (val) => {
                            props.color = val;
                            this.updateMeshColor(component.mesh, val);
                        });
                        
                        // ÊòæÁ§∫ËÆ°ÁÆóÂá∫ÁöÑÈÄèÈïúÂèÇÊï∞
                        const R = 2 * Math.abs(props.focalLength) * (props.ior - 1);
                        const sagitta = Math.pow(props.diameter/2, 2) / (2 * R);
                        html += `<div style="margin-top: 10px; padding: 5px; background: rgba(0, 100, 200, 0.2); border-radius: 3px; font-size: 11px;">
                            <strong>ËÆ°ÁÆóÂèÇÊï∞:</strong><br>
                            Êõ≤ÁéáÂçäÂæÑ: ${R.toFixed(1)} mm<br>
                            Áü¢È´ò: ${sagitta.toFixed(2)} mm<br>
                            ÈÄèÈïúÁ±ªÂûã: ${props.focalLength > 0 ? 'Âá∏ÈÄèÈïú' : 'ÂáπÈÄèÈïú'}
                        </div>`;
                        break;
                        
                    case 'mirror':
                        html += this.createSlider("ÂèçÂ∞ÑÁéá", props.reflectivity, 0.5, 1.0, 0.01, (val) => {
                            props.reflectivity = val;
                            this.needsRayUpdate = true;
                        });
                        if (component.subtype === 'plane') {
                            html += this.createSlider("ÂÆΩÂ∫¶ (mm)", props.width, 10, 50, 1, (val) => {
                                props.width = val;
                                this.updateMirrorSize(component, val, props.height);
                                this.needsRayUpdate = true;
                            });
                            html += this.createSlider("È´òÂ∫¶ (mm)", props.height, 10, 50, 1, (val) => {                                props.height = val;
                                this.updateMirrorSize(component, props.width, val);
                                this.needsRayUpdate = true;
                            });
                        } else {
                            html += this.createSlider("Áõ¥ÂæÑ (mm)", props.diameter, 10, 50, 1, (val) => {
                                props.diameter = val;
                                this.updateMirrorSize(component, val, val);
                                this.needsRayUpdate = true;
                            });
                        }
                        html += this.createColorPicker("È¢úËâ≤", props.color, (val) => {
                            props.color = val;
                            this.updateMeshColor(component.mesh, val);
                        });
                        break;
                        
                    case 'prism':
                        html += this.createSlider("ÊäòÂ∞ÑÁéá", props.ior, 1.0, 2.5, 0.01, (val) => {
                            props.ior = val;
                            component.mesh.metadata.ior = val;
                            this.needsRayUpdate = true;
                        });
                        html += this.createSlider("È°∂Ëßí (Â∫¶)", props.apexAngle, 30, 90, 1, (val) => {
                            props.apexAngle = val;
                            this.needsRayUpdate = true;
                        });
                        html += this.createSlider("Â∞∫ÂØ∏ (mm)", props.size, 10, 30, 1, (val) => {
                            props.size = val;
                            this.updatePrismSize(component, val);
                            this.needsRayUpdate = true;
                        });
                        html += this.createSlider("ÈÄèÊòéÂ∫¶", props.transparency, 0.3, 1.0, 0.05, (val) => {
                            props.transparency = val;
                            if (component.mesh.material) {
                                component.mesh.material.alpha = val;
                            }
                        });
                        html += this.createColorPicker("È¢úËâ≤", props.color, (val) => {
                            props.color = val;
                            this.updateMeshColor(component.mesh, val);
                        });
                        break;
                        
                    case 'grating':
                        html += this.createSlider("Á∫øÂØÜÂ∫¶ (Á∫ø/mm)", props.linesPerMM, 100, 2000, 10, (val) => {
                            props.linesPerMM = val;
                            this.updateGratingTexture(component);
                            this.needsRayUpdate = true;
                        });
                        html += this.createSlider("ÊïàÁéá", props.efficiency, 0.1, 1.0, 0.05, (val) => {
                            props.efficiency = val;
                            this.needsRayUpdate = true;
                        });
                        html += this.createSlider("Â∞∫ÂØ∏ (mm)", props.size, 10, 40, 1, (val) => {
                            props.size = val;
                            component.mesh.scaling = new BABYLON.Vector3(val/20, val/20, 1);
                            this.needsRayUpdate = true;
                        });
                        html += this.createColorPicker("È¢úËâ≤", props.color, (val) => {
                            props.color = val;
                            this.updateMeshColor(component.mesh, val);
                        });
                        break;
                        
                    case 'screen':
                        html += this.createSlider("ÂÆΩÂ∫¶ (mm)", props.width, 10, 60, 1, (val) => {
                            props.width = val;
                            this.updateScreenSize(component, val, props.height);
                        });
                        html += this.createSlider("È´òÂ∫¶ (mm)", props.height, 10, 60, 1, (val) => {
                            props.height = val;
                            this.updateScreenSize(component, props.width, val);
                        });
                        html += this.createColorPicker("È¢úËâ≤", props.color, (val) => {
                            props.color = val;
                            this.updateMeshColor(component.mesh, val);
                        });
                        break;
                }
                
                return html;
            }

            createSlider(label, value, min, max, step, callback) {
                const id = 'slider_' + Math.random().toString(36).substr(2, 9);
                
                // Â≠òÂÇ®ÂõûË∞ÉÂáΩÊï∞
                if (!window.sliderCallbacks) window.sliderCallbacks = {};
                window.sliderCallbacks[id] = callback;
                
                return `
                    <div class="prop-slider">
                        <label>${label}</label>
                        <input type="range" id="${id}" min="${min}" max="${max}" step="${step}" value="${value}">
                        <input type="number" id="${id}_text" value="${parseFloat(value).toFixed(2)}" min="${min}" max="${max}" step="${step}">
                    </div>
                `;
            }

            createColorPicker(label, value, callback) {
                const id = 'color_' + Math.random().toString(36).substr(2, 9);
                
                // Â≠òÂÇ®ÂõûË∞ÉÂáΩÊï∞
                if (!window.colorCallbacks) window.colorCallbacks = {};
                window.colorCallbacks[id] = callback;
                
                return `
                    <div class="prop-color">
                        <label>${label}</label>
                        <input type="color" id="${id}" value="${value}">
                    </div>
                `;
            }

            setupSliderEvents() {
                document.querySelectorAll('#propertyControls input[type="range"]').forEach(slider => {
                    const textInput = document.getElementById(slider.id + '_text');
                    
                    const updateValue = (value) => {
                        value = parseFloat(value);
                        if (!isNaN(value)) {
                            slider.value = value;
                            textInput.value = value.toFixed(2);
                            
                            const callback = window.sliderCallbacks[slider.id];
                            if (callback) callback(value);
                        }
                    };
                    
                    slider.oninput = () => updateValue(slider.value);
                    textInput.onchange = () => updateValue(textInput.value);
                });
            }

            setupColorEvents() {
                document.querySelectorAll('#propertyControls input[type="color"]').forEach(colorPicker => {
                    colorPicker.onchange = () => {
                        const callback = window.colorCallbacks[colorPicker.id];
                        if (callback) callback(colorPicker.value);
                    };
                });
            }

            updateLaserColor(component, wavelength) {
                // Ê†πÊçÆÊ≥¢ÈïøËÆ°ÁÆóÈ¢úËâ≤
                let r, g, b;
                if (wavelength >= 380 && wavelength < 440) {
                    r = -(wavelength - 440) / (440 - 380);
                    g = 0.0;
                    b = 1.0;
                } else if (wavelength >= 440 && wavelength < 490) {
                    r = 0.0;
                    g = (wavelength - 440) / (490 - 440);
                    b = 1.0;
                } else if (wavelength >= 490 && wavelength < 510) {
                    r = 0.0;
                    g = 1.0;
                    b = -(wavelength - 510) / (510 - 490);
                } else if (wavelength >= 510 && wavelength < 580) {
                    r = (wavelength - 510) / (580 - 510);
                    g = 1.0;
                    b = 0.0;
                } else if (wavelength >= 580 && wavelength < 645) {
                    r = 1.0;
                    g = -(wavelength - 645) / (645 - 580);
                    b = 0.0;
                } else if (wavelength >= 645 && wavelength <= 750) {
                    r = 1.0;
                    g = 0.0;
                    b = 0.0;
                } else {
                    r = 1.0;
                    g = 0.0;
                    b = 0.0;
                }
                
                const color = new BABYLON.Color3(r, g, b);
                component.mesh.material.diffuseColor = color;
                component.mesh.material.emissiveColor = color.scale(0.3);
                component.properties.color = this.color3ToHex(color);
            }

            updateMeshColor(mesh, hex) {
                if (mesh.material) {
                    mesh.material.diffuseColor = this.hexToColor3(hex);
                }
            }

            updateLensSize(component, diameter) {
                // Áõ¥ÂæÑÊîπÂèòÊó∂ÈáçÊñ∞ÂàõÂª∫ÈÄèÈïú‰ª•‰øùÊåÅÊ≠£Á°ÆÁöÑÊØî‰æã
                this.updateLensShape(component);
            }
            
            updateLensShape(component) {
                const focalLength = component.properties.focalLength || 50;
                const diameter = component.properties.diameter || 25;
                const ior = component.properties.ior || 1.5;
                const userThickness = component.properties.thickness || null;
                
                // ‰øùÂ≠òÂΩìÂâçÁä∂ÊÄÅ
                const oldPosition = component.mesh.position.clone();
                const oldRotation = component.mesh.rotation.clone();
                const oldMaterial = component.mesh.material;
                
                // Âà†Èô§ÊóßÁΩëÊ†º
                component.mesh.dispose();
                
                // ËÆ°ÁÆóÈÄèÈïúÂèÇÊï∞Ôºà‰ºòÂÖà‰ΩøÁî®Áî®Êà∑ËÆæÁΩÆÁöÑÂéöÂ∫¶Ôºâ
                const isConvex = focalLength > 0;
                const R = 2 * Math.abs(focalLength) * (ior - 1);
                const sagitta = Math.pow(diameter/2, 2) / (2 * R);
                const minThickness = Math.max(0.5, diameter * 0.02);
                const maxThickness = diameter * 0.6;
                
                let centerThickness;
                if (userThickness !== null && userThickness > 0) {
                    centerThickness = Math.max(minThickness, Math.min(maxThickness, userThickness));
                } else {
                    if (focalLength > 0) {
                        centerThickness = Math.max(minThickness, Math.min(maxThickness, sagitta * 2 + minThickness));
                    } else {
                        centerThickness = Math.max(minThickness, maxThickness - sagitta * 1.5);
                    }
                }
                
                // ÂàõÂª∫Êñ∞ÁöÑÈÄèÈïúÁΩëÊ†º
                let newMesh;
                if (isConvex) {
                    newMesh = this.createConvexLens(diameter, centerThickness, R);
                } else {
                    newMesh = this.createConcaveLens(diameter, centerThickness, R);
                }
                
                // ÊÅ¢Â§çÁä∂ÊÄÅ
                newMesh.position = oldPosition;
                newMesh.rotation = oldRotation;
                newMesh.material = oldMaterial;
                
                // Á°Æ‰øùÊñ∞meshÂèØ‰ª•Ë¢´ÊãæÂèñ
                newMesh.isPickable = true;
                
                // Êõ¥Êñ∞ÁªÑ‰ª∂ÂºïÁî®
                component.mesh = newMesh;
                
                // Êõ¥Êñ∞metadata
                component.mesh.metadata = {
                    type: 'refractive',
                    ior: ior,
                    component: component
                };
                
                // Â¶ÇÊûúÂΩìÂâçÁªÑ‰ª∂Ë¢´ÈÄâ‰∏≠ÔºåÈúÄË¶ÅÈáçÊñ∞ÈÄâÊã©‰ª•Êõ¥Êñ∞Gizmo
                if (this.selectedComponent === component) {
                    // ‰∏¥Êó∂Ê∏ÖÈô§ÈÄâÊã©
                    this.selectedComponent = null;
                    // ÈáçÊñ∞ÈÄâÊã©‰ª•Êõ¥Êñ∞GizmoÈôÑÁùÄ
                    setTimeout(() => {
                        this.selectComponent(component);
                    }, 50);
                }
                
                console.log(`ÈÄèÈïúÂΩ¢Áä∂Â∑≤Êõ¥Êñ∞: ÁÑ¶Ë∑ù=${focalLength}mm, Áõ¥ÂæÑ=${diameter}mm, ÂéöÂ∫¶=${centerThickness.toFixed(1)}mm, Á±ªÂûã=${isConvex ? 'Âá∏ÈÄèÈïú' : 'ÂáπÈÄèÈïú'}`);
            }

            updateMirrorSize(component, width, height) {
                if (component.subtype === 'plane') {
                    component.mesh.scaling.x = width / 25;
                    component.mesh.scaling.y = height / 25;
                } else {
                    // ÂáπÈù¢Èïú
                    const scale = width / 25;
                    component.mesh.scaling.y = scale;
                    component.mesh.scaling.z = scale;
                }
            }

            updatePrismSize(component, size) {
                const scale = size / 15; // Âü∫ÂáÜÂ∞∫ÂØ∏
                component.mesh.scaling = new BABYLON.Vector3(scale, scale, scale);
            }

            updateScreenSize(component, width, height) {
                component.mesh.scaling.x = width / 30;
                component.mesh.scaling.y = height / 30;
            }

            updateGratingTexture(component) {
                if (component.mesh.material && component.mesh.material.diffuseTexture) {
                    const texture = component.mesh.material.diffuseTexture;
                    const ctx = texture.getContext();
                    
                    // ÈáçÊñ∞ÁªòÂà∂ÂÖâÊ†ÖÁ∫πÁêÜ
                    ctx.fillStyle = "#808080";
                    ctx.fillRect(0, 0, 512, 512);
                    
                    const lineCount = Math.min(50, component.properties.linesPerMM / 10);
                    const lineWidth = 512 / lineCount;
                    
                    ctx.fillStyle = "#404040";
                    for (let i = 0; i < lineCount; i += 2) {
                        ctx.fillRect(i * lineWidth, 0, lineWidth / 2, 512);
                    }
                    
                    texture.update();
                }
            }

            removeSelectedComponent() {
                if (this.selectedComponent) {
                    const index = this.components.indexOf(this.selectedComponent);
                    if (index > -1) {
                        this.selectedComponent.mesh.dispose();
                        this.components.splice(index, 1);
                        this.clearSelection();
                        this.needsRayUpdate = true;
                    }
                }
            }

            updateRayTracing() {
                // È´òÊÄßËÉΩÂÖâÁ∫øËøΩË∏™ - ÁßªÈô§ÊâÄÊúâÈôêÂà∂
                try {
                    // Ê∏ÖÈô§ÊóßÂÖâÁ∫ø
                    this.rayLines.forEach(line => {
                        if (line && line.dispose) {
                            line.dispose();
                        }
                    });
                    this.rayLines = [];
                    
                    // ÊâæÂà∞ÊâÄÊúâÂÖâÊ∫ê
                    const lightSources = this.components.filter(comp => comp.type === 'laser');
                    
                    // Âπ∂Ë°åÂ§ÑÁêÜÂ§ö‰∏™ÂÖâÊ∫êÔºàÂ¶ÇÊûúÊîØÊåÅÔºâ
                    lightSources.forEach(source => {
                        // Âü∫Á°ÄÂÖâÁ∫ø
                        this.traceRaysFromSource(source);
                        
                        // Â¶ÇÊûúÂêØÁî®È´òÁ∫ßÂÖâÁ∫øËøΩË∏™ÔºåÊ∑ªÂä†Â§öÊù°ÂÖâÁ∫ø‰ª•Ê®°ÊãüÂÖâÊùü
                        if (this.enableAdvancedRayTracing && this.rayDensity > 1) {
                            for (let i = 1; i < this.rayDensity; i++) {
                                const offset = (i / this.rayDensity - 0.5) * 0.1;
                                this.traceRaysFromSource(source, offset);
                            }
                        }
                    });
                    
                    console.log(`ÂÆûÊó∂ÂÖâÁ∫øËøΩË∏™ÂÆåÊàê: ${this.rayLines.length} Êù°ÂÖâÁ∫ø, ${lightSources.length} ‰∏™ÂÖâÊ∫ê`);
                } catch (error) {
                    console.error('ÂÖâÁ∫øËøΩË∏™ÈîôËØØ:', error);
                }
            }

            traceRaysFromSource(source, offsetY = 0) {
                try {
                    const laserDirection = source.mesh.getDirection(new BABYLON.Vector3(1, 0, 0));
                    
                    // ËÆ°ÁÆóËµ∑Âßã‰ΩçÁΩÆÔºàÂèØ‰ª•Ê∑ªÂä†ÂÅèÁßª‰ª•Ê®°ÊãüÂÖâÊùüÂÆΩÂ∫¶Ôºâ
                    let startPosition = source.mesh.position.clone();
                    if (offsetY !== 0) {
                        startPosition.y += offsetY;
                    }
                    
                    let currentRay = new BABYLON.Ray(startPosition, laserDirection, 200); // Â¢ûÂä†ÂÖâÁ∫øÈïøÂ∫¶
                    let currentIor = 1.0; // Á©∫Ê∞îÊäòÂ∞ÑÁéá
                    let rayIntensity = 1.0; // ÂÖâÁ∫øÂº∫Â∫¶
                    
                    // Â¢ûÂä†ÊúÄÂ§ßÂèçÂºπÊ¨°Êï∞‰ª•Ëé∑ÂæóÊõ¥Á≤æÁ°ÆÁöÑËøΩË∏™
                    for (let i = 0; i < this.maxBounces; i++) {
                        // Âè™Ê£ÄÊµãÂÖâÂ≠¶ÁªÑ‰ª∂ÔºåÊéíÈô§ÂÖâÊ∫êÊú¨Ë∫´
                        const opticalMeshes = this.components
                            .filter(comp => comp !== source && comp.mesh)
                            .map(comp => comp.mesh);
                        
                        const pickInfo = this.scene.pickWithRay(currentRay, (mesh) => 
                            opticalMeshes.includes(mesh)
                        );
                        
                        if (!pickInfo || !pickInfo.hit) {
                            // ÂÖâÁ∫øÂª∂‰º∏Âà∞Âú∫ÊôØËæπÁïå
                            const endPoint = currentRay.origin.add(currentRay.direction.scale(20));
                            this.drawRay(currentRay.origin, endPoint, source.properties.wavelength);
                            break;
                        }
                        
                        const hitMesh = pickInfo.pickedMesh;
                        const hitPoint = pickInfo.pickedPoint;
                        
                        // ÁîªÂá∫Âà∞‰∫§ÁÇπÁöÑÂÖâÁ∫ø
                        this.drawRay(currentRay.origin, hitPoint, source.properties.wavelength);
                        
                        const normal = pickInfo.getNormal(true);
                        const metadata = hitMesh.metadata;
                        
                        if (!metadata || !metadata.type) break;
                        
                        // Ê†πÊçÆÂÖâÂ≠¶ÁªÑ‰ª∂Á±ªÂûãÂ§ÑÁêÜÂÖâÁ∫ø
                        if (metadata.type === "reflective") {
                            // ÂèçÂ∞Ñ
                            const reflectionDirection = BABYLON.Vector3.Reflect(currentRay.direction, normal);
                            currentRay = new BABYLON.Ray(hitPoint.add(reflectionDirection.scale(0.001)), reflectionDirection, 100);
                        } 
                        else if (metadata.type === "refractive") {
                            // ÊäòÂ∞Ñ
                            const n1 = currentIor;
                            const n2 = (currentIor === 1.0) ? metadata.ior : 1.0;
                            
                            const cosI = -BABYLON.Vector3.Dot(currentRay.direction, normal);
                            const sinT2 = (n1 / n2) * (n1 / n2) * (1.0 - cosI * cosI);
                            
                            if (sinT2 > 1.0) { 
                                // ÂÖ®ÂÜÖÂèçÂ∞Ñ
                                const reflectionDirection = BABYLON.Vector3.Reflect(currentRay.direction, normal);
                                currentRay = new BABYLON.Ray(hitPoint.add(reflectionDirection.scale(0.001)), reflectionDirection, 100);
                            } else {
                                // ÊñØÊ∂ÖÂ∞îÂÆöÂæãÊäòÂ∞Ñ
                                const cosT = Math.sqrt(1.0 - sinT2);
                                const refractionDirection = currentRay.direction.scale(n1 / n2)
                                    .add(normal.scale((n1 / n2) * cosI - cosT));
                                currentRay = new BABYLON.Ray(hitPoint.add(refractionDirection.scale(0.001)), refractionDirection, 100);
                                currentIor = n2;
                            }
                        }
                        else if (metadata.type === "diffractive") {
                            // ÁÆÄÂåñÁöÑË°çÂ∞ÑÂ§ÑÁêÜ
                            const gratingComponent = metadata.component;
                            const wavelength = source.properties.wavelength || 632.8;
                            const gratingSpacing = 1.0 / (gratingComponent.properties.linesPerMM || 500);
                            
                            // ËÆ°ÁÆó‰∏ÄÁ∫ßË°çÂ∞Ñ
                            const incidentAngle = Math.acos(-BABYLON.Vector3.Dot(currentRay.direction, normal));
                            const sinDiffracted = Math.sin(incidentAngle) + (wavelength * 1e-6) / gratingSpacing;
                            
                                                        if (Math.abs(sinDiffracted) <= 1) {
                                const diffractedAngle = Math.asin(sinDiffracted);
                                
                                // ËÆ°ÁÆóË°çÂ∞ÑÊñπÂêë
                                const right = normal.cross(BABYLON.Vector3.Up()).normalize();
                                const diffractedDirection = normal.scale(-Math.cos(diffractedAngle))
                                    .add(right.scale(Math.sin(diffractedAngle)));
                                
                                const diffractedRay = new BABYLON.Ray(hitPoint, diffractedDirection, 20);
                                const endPoint = diffractedRay.origin.add(diffractedRay.direction.scale(20));
                                
                                this.drawRay(diffractedRay.origin, endPoint, wavelength, 0.7);
                            }
                            
                            // Èõ∂Á∫ßË°çÂ∞ÑÔºàÁõ¥Êé•ÈÄèÂ∞ÑÔºâ
                            currentRay = new BABYLON.Ray(hitPoint.add(currentRay.direction.scale(0.001)), currentRay.direction, 100);
                        }
                        else {
                            // Âê∏Êî∂ (Â¶ÇÂ±èÂπï)
                            break;
                        }
                    }
                } catch (error) {
                    console.error('ÂÖâÁ∫øËøΩË∏™ÈîôËØØ:', error);
                }
            }

            drawRay(start, end, wavelength = 632.8, intensity = 1.0) {
                try {
                    // È´òÊÄßËÉΩÂÖâÁ∫øÁªòÂà∂
                    const line = BABYLON.MeshBuilder.CreateLines("rayLine", {
                        points: [start, end],
                        updatable: false, // Á¶ÅÁî®ÂèØÊõ¥Êñ∞‰ª•ÊèêÂçáÊÄßËÉΩ
                        useVertexAlpha: false // Á¶ÅÁî®È°∂ÁÇπalpha‰ª•ÊèêÂçáÊÄßËÉΩ
                    }, this.scene);
                    
                    // Ê†πÊçÆÊ≥¢ÈïøËÆæÁΩÆÈ¢úËâ≤
                    const color = this.wavelengthToColor(wavelength);
                    line.color = color.scale(intensity);
                    line.alpha = Math.min(0.9 * intensity, 0.95); // Á®çÂæÆÊèêÈ´òalphaÂÄº‰ª•Ëé∑ÂæóÊõ¥Â•ΩÁöÑÂèØËßÅÊÄß
                    
                    // ÊÄßËÉΩ‰ºòÂåñËÆæÁΩÆ
                    line.isPickable = false; // Á¶ÅÁî®ÊãæÂèñ‰ª•ÊèêÂçáÊÄßËÉΩ
                    line.doNotSyncBoundingInfo = true; // Á¶ÅÁî®ËæπÁïå‰ø°ÊÅØÂêåÊ≠•
                    line.freezeWorldMatrix(); // ÂÜªÁªì‰∏ñÁïåÁü©Èòµ‰ª•ÊèêÂçáÊÄßËÉΩ
                    
                    this.rayLines.push(line);
                } catch (error) {
                    console.error('ÁªòÂà∂ÂÖâÁ∫øÈîôËØØ:', error);
                }
            }

            wavelengthToColor(wavelength) {
                let r, g, b;
                
                if (wavelength >= 380 && wavelength < 440) {
                    r = -(wavelength - 440) / (440 - 380);
                    g = 0.0;
                    b = 1.0;
                } else if (wavelength >= 440 && wavelength < 490) {
                    r = 0.0;
                    g = (wavelength - 440) / (490 - 440);
                    b = 1.0;
                } else if (wavelength >= 490 && wavelength < 510) {
                    r = 0.0;
                    g = 1.0;
                    b = -(wavelength - 510) / (510 - 490);
                } else if (wavelength >= 510 && wavelength < 580) {
                    r = (wavelength - 510) / (580 - 510);
                    g = 1.0;
                    b = 0.0;
                } else if (wavelength >= 580 && wavelength < 645) {
                    r = 1.0;
                    g = -(wavelength - 645) / (645 - 580);
                    b = 0.0;
                } else if (wavelength >= 645 && wavelength <= 750) {
                    r = 1.0;
                    g = 0.0;
                    b = 0.0;
                } else {
                    r = 1.0;
                    g = 0.0;
                    b = 0.0;
                }
                
                return new BABYLON.Color3(r, g, b);
            }

            updateSystemInfo() {
                try {
                    const rayInfo = document.getElementById('rayInfo');
                    const performanceInfo = document.getElementById('performanceInfo');
                    const distanceInfo = document.getElementById('distanceInfo');
                    
                    if (rayInfo) {
                        rayInfo.innerHTML = `
                            <strong>ÂÖâÁ∫ø‰ø°ÊÅØ:</strong><br>
                            ÂÖâÁ∫øÊÆµÊï∞: ${this.rayLines.length}<br>
                            ÁªÑ‰ª∂Êï∞Èáè: ${this.components.length}<br>
                            ÂÖâÊ∫êÊï∞Èáè: ${this.components.filter(c => c.type === 'laser').length}<br>
                            ${this.selectedComponent ? `<span style="color: #00ff88;">ÈÄâ‰∏≠: ${this.selectedComponent.type} (${this.transformMode})</span>` : ''}
                        `;
                    }
                    
                    if (performanceInfo && this.engine) {
                        const fps = this.engine.getFps();
                        const drawCalls = this.scene.getActiveMeshes().length;
                        const totalVertices = this.scene.getTotalVertices();
                        const memoryUsage = this.scene.meshes.length + this.rayLines.length;
                        
                        performanceInfo.innerHTML = `
                            <strong>ÂÆûÊó∂ÊÄßËÉΩ‰ø°ÊÅØ:</strong><br>
                            FPS: ${fps.toFixed(1)} ${fps >= 60 ? 'üü¢' : fps >= 30 ? 'üü°' : 'üî¥'}<br>
                            ÁªòÂà∂Ë∞ÉÁî®: ${drawCalls}<br>
                            Ê¥ªÂä®ÁΩëÊ†º: ${this.scene.meshes.length}<br>
                            ÊÄªÈ°∂ÁÇπÊï∞: ${totalVertices}<br>
                            ÂÖâÁ∫øÊï∞Èáè: ${this.rayLines.length}<br>
                            ÂÜÖÂ≠ò‰ΩøÁî®: ${memoryUsage} ÂØπË±°<br>
                            ${this.enableRealtimeRayTracing ? '<span style="color: #00ff88;">‚ö° ÂÆûÊó∂ÂÖâÁ∫øËøΩË∏™</span>' : '<span style="color: #ffaa00;">‚è∏Ô∏è ÈôêÂà∂Ê®°Âºè</span>'}
                        `;
                    }
                    
                    if (distanceInfo && this.components.length >= 2) {
                        let html = '<strong>ÁªÑ‰ª∂Èó¥Ë∑ùÁ¶ª:</strong><br>';
                        let count = 0;
                        
                        // ‰ºòÂÖàÊòæÁ§∫ÂÖâÊ∫êÂà∞ÂÖ∂‰ªñÁªÑ‰ª∂ÁöÑË∑ùÁ¶ª
                        const lasers = this.components.filter(c => c.type === 'laser');
                        const others = this.components.filter(c => c.type !== 'laser');
                        
                        for (let laser of lasers) {
                            for (let other of others) {
                                if (count >= 3) break;
                                
                                const distance = BABYLON.Vector3.Distance(
                                    laser.mesh.position,
                                    other.mesh.position
                                );
                                
                                html += `${laser.type} ‚Üí ${other.type}: ${(distance * 10).toFixed(1)} mm<br>`;
                                count++;
                            }
                            if (count >= 3) break;
                        }
                        
                        distanceInfo.innerHTML = html;
                    } else if (distanceInfo) {
                        distanceInfo.innerHTML = '<strong>Ë∑ùÁ¶ª‰ø°ÊÅØ:</strong><br>ÈúÄË¶ÅËá≥Â∞ë2‰∏™ÁªÑ‰ª∂';
                    }
                } catch (error) {
                    console.error('Êõ¥Êñ∞Á≥ªÁªü‰ø°ÊÅØÈîôËØØ:', error);
                }
            }

            // üî• ÊûÅÈôêÊÄßËÉΩ‰ºòÂåñËÆæÁΩÆ
            setupExtremePerformanceMode() {
                // ‰∏¥Êó∂Á¶ÅÁî®ÊûÅÈôêÊÄßËÉΩÊ®°ÂºèÊù•ÊµãËØïÈº†Ê†áÊãæÂèñ
                console.log('‚ö†Ô∏è ÊûÅÈôêÊÄßËÉΩÊ®°ÂºèÂ∑≤‰∏¥Êó∂Á¶ÅÁî®‰ª•Á°Æ‰øùÈº†Ê†áÊãæÂèñÂäüËÉΩÊ≠£Â∏∏');
                return;
                
                if (!this.enableHighPerformanceMode) return;
                
                console.log('üî• ÈÖçÁΩÆÊûÅÈôêÊÄßËÉΩÊ®°Âºè...');
                
                // Âú∫ÊôØÁ∫ßÂà´ÊûÅÈôê‰ºòÂåñ
                this.scene.skipPointerMovePicking = true; // Ë∑≥ËøáÊåáÈíàÁßªÂä®ÊãæÂèñ
                this.scene.skipPointerDownPicking = false; // ‰øùÁïôÁÇπÂáªÊãæÂèñ
                this.scene.skipPointerUpPicking = true; // Ë∑≥ËøáÊåáÈíàÊä¨Ëµ∑ÊãæÂèñ
                this.scene.constantlyUpdateMeshUnderPointer = false; // Á¶ÅÁî®ÊåÅÁª≠Êõ¥Êñ∞ÊåáÈíà‰∏ãÁΩëÊ†º
                this.scene.hoverCursor = 'default'; // ÁÆÄÂåñÈº†Ê†áÊ†∑Âºè
                
                // Ê∏≤Êüì‰ºòÂåñ
                this.scene.autoClear = true; // Ëá™Âä®Ê∏ÖÈô§
                this.scene.autoClearDepthAndStencil = false; // Á¶ÅÁî®Ê∑±Â∫¶Ê®°ÊùøËá™Âä®Ê∏ÖÈô§‰ª•ËäÇÁúÅGPUÊó∂Èó¥
                
                // Âº∫Âà∂ËÆæÁΩÆÈ´òÂàÜËæ®ÁéáÁ∫πÁêÜÂíåÂ§çÊùÇÂá†‰Ωï‰Ωì‰ª•Â¢ûÂä†GPUË¥üËΩΩ
                this.scene.getEngine().setSize(Math.max(1920, window.innerWidth), Math.max(1080, window.innerHeight), false);
                
                // WebGLÊûÅÈôê‰ºòÂåñ
                const gl = this.engine._gl;
                if (gl) {
                    // ÂêØÁî®ÊâÄÊúâÂèØÁî®ÁöÑWebGLÊâ©Â±ï
                    const extensions = [
                        'OES_texture_float',
                        'OES_texture_float_linear',
                        'WEBGL_depth_texture',
                        'OES_element_index_uint',
                        'WEBGL_lose_context',
                        'WEBGL_compressed_texture_s3tc',
                        'WEBGL_compressed_texture_pvrtc',
                        'WEBGL_compressed_texture_etc1',
                        'EXT_texture_filter_anisotropic',
                        'WEBGL_draw_buffers'
                    ];
                    
                    extensions.forEach(ext => {
                        const extension = gl.getExtension(ext);
                        if (extension) {
                            console.log(`‚úÖ WebGLÊâ©Â±ïÂ∑≤ÂêØÁî®: ${ext}`);
                        }
                    });
                    
                    // ÊòæÁ§∫GPU‰ø°ÊÅØ
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    if (debugInfo) {
                        console.log('üéÆ GPUÂûãÂè∑:', gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL));
                        console.log('üè¢ GPUÂéÇÂïÜ:', gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL));
                    }
                    
                    // Ëé∑ÂèñÂπ∂ÊòæÁ§∫WebGLÈôêÂà∂‰ø°ÊÅØ
                    console.log('üìä WebGLÊûÅÈôêÂèÇÊï∞:');
                    console.log('  ÊúÄÂ§ßÁ∫πÁêÜÂ∞∫ÂØ∏:', gl.getParameter(gl.MAX_TEXTURE_SIZE));
                    console.log('  ÊúÄÂ§ßÁ´ãÊñπ‰ΩìÁ∫πÁêÜÂ∞∫ÂØ∏:', gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE));
                    console.log('  ÊúÄÂ§ßÈ°∂ÁÇπÂ±ûÊÄß:', gl.getParameter(gl.MAX_VERTEX_ATTRIBS));
                    console.log('  ÊúÄÂ§ßÈ°∂ÁÇπÁ∫πÁêÜÂçïÂÖÉ:', gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS));
                    console.log('  ÊúÄÂ§ßÁâáÊÆµÁ∫πÁêÜÂçïÂÖÉ:', gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS));
                    console.log('  ÊúÄÂ§ßÊ∏≤ÊüìÁºìÂÜ≤Âå∫Â∞∫ÂØ∏:', gl.getParameter(gl.MAX_RENDERBUFFER_SIZE));
                    
                    // ËÆæÁΩÆWebGLÁä∂ÊÄÅ‰ª•ÊúÄÂ§ßÂåñÊÄßËÉΩ
                    gl.enable(gl.DEPTH_TEST);
                    gl.enable(gl.CULL_FACE);
                    gl.cullFace(gl.BACK);
                    gl.frontFace(gl.CCW);
                }
                
                // Âº∫Âà∂ÂêØÁî®ÊâÄÊúâBabylon.jsÊÄßËÉΩÈÄâÈ°π
                this.engine.loadingUIBackgroundColor = '#000000';
                this.engine.enableOfflineSupport = false;
                this.engine.disableManifestCheck = true;
                
                // ÂàõÂª∫Â§ßÈáèÂ§çÊùÇÂá†‰Ωï‰Ωì‰ª•Â¢ûÂä†GPUÂ∑•‰ΩúË¥üËΩΩ
                this.createPerformanceTestObjects();
                
                console.log('üöÄ ÊûÅÈôêÊÄßËÉΩÊ®°ÂºèÈÖçÁΩÆÂÆåÊàêÔºÅ');
            }
            
            // ÂàõÂª∫ÊÄßËÉΩÊµãËØïÂØπË±°‰ª•Â¢ûÂä†GPUË¥üËΩΩ
            createPerformanceTestObjects() {
                if (!this.enableHighPerformanceMode) return;
                
                console.log('üîß ÂàõÂª∫GPUË¥üËΩΩÊµãËØïÂØπË±°...');
                
                // ÂàõÂª∫È´òÂ§öËæπÂΩ¢ÁΩëÊ†º‰ª•Â¢ûÂä†GPUË¥üËΩΩ
                const testMeshes = [];
                for (let i = 0; i < 10; i++) {
                    // ÂàõÂª∫È´òÁªÜÂàÜÂ∫¶ÁöÑÁêÉ‰Ωì
                    const sphere = BABYLON.MeshBuilder.CreateSphere(`perfTestSphere${i}`, {
                        diameter: 0.1,
                        segments: 32 // È´òÁªÜÂàÜÂ∫¶
                    }, this.scene);
                    
                    sphere.position = new BABYLON.Vector3(
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 20
                    );
                    
                    // ÂàõÂª∫Â§çÊùÇÊùêË¥®
                    const material = new BABYLON.StandardMaterial(`perfTestMat${i}`, this.scene);
                    material.diffuseColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random());
                    material.specularColor = new BABYLON.Color3(1, 1, 1);
                    material.specularPower = 64;
                    material.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                    
                    sphere.material = material;
                    sphere.isVisible = false; // ÈöêËóè‰ΩÜ‰ªçÂèÇ‰∏éÊ∏≤ÊüìËÆ°ÁÆó
                    testMeshes.push(sphere);
                }
                
                // Ê∑ªÂä†Âä®Áîª‰ª•Â¢ûÂä†ÊØèÂ∏ßËÆ°ÁÆóË¥üËΩΩ
                this.scene.registerBeforeRender(() => {
                    testMeshes.forEach((mesh, index) => {
                        mesh.rotation.x += 0.01 * (index + 1);
                        mesh.rotation.y += 0.005 * (index + 1);
                        mesh.position.y = Math.sin(Date.now() * 0.001 + index) * 0.5;
                    });
                });
                
                console.log(`‚úÖ Â∑≤ÂàõÂª∫ ${testMeshes.length} ‰∏™GPUË¥üËΩΩÊµãËØïÂØπË±°`);
            }

            startRenderLoop() {
                console.log('üî• ÂêØÂä®ÊûÅÈôêÊÄßËÉΩÊ∏≤ÊüìÂæ™ÁéØ...');
                
                // ËÆæÁΩÆÊúÄÂ§ßÂ∏ßÁéáÔºàÁßªÈô§ÈôêÂà∂Ôºâ
                this.engine.setSize(window.innerWidth, window.innerHeight, false);
                
                // Âº∫Âà∂WebGLÁä∂ÊÄÅ‰ºòÂåñ
                const gl = this.engine._gl;
                if (gl) {
                    // ËÆæÁΩÆÊúÄÂ§ßËßÜÁ™ó
                    gl.viewport(0, 0, window.innerWidth, window.innerHeight);
                    // ÂÖ≥Èó≠‰∏çÂøÖË¶ÅÁöÑWebGLÂäüËÉΩ
                    gl.disable(gl.SCISSOR_TEST);
                    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
                    gl.disable(gl.SAMPLE_COVERAGE);
                }
                
                // ÊûÅÈôêÊÄßËÉΩÊ∏≤ÊüìÂæ™ÁéØ
                this.engine.runRenderLoop(() => {
                    if (this.scene && this.scene.isReady()) {
                        // Âº∫Âà∂ÊØèÂ∏ßÊ∏≤Êüì
                        this.scene.render();
                        
                        // Âº∫Âà∂GPUÂ∑•‰ΩúË¥üËΩΩÔºàÂ¢ûÂä†ËÆ°ÁÆóÂ§çÊùÇÂ∫¶Ôºâ
                        if (this.enableHighPerformanceMode) {
                            // È¢ùÂ§ñÁöÑGPUËÆ°ÁÆóË¥üËΩΩ
                            this.scene.forceShowBoundingBoxes = false;
                            this.scene.forceWireframe = false;
                            
                            // Âº∫Âà∂ÊùêË¥®Êõ¥Êñ∞‰ª•Â¢ûÂä†GPUË¥üËΩΩ
                            if (this.components.length > 0 && this.forceRender) {
                                this.scene.markAllMaterialsAsDirty(BABYLON.Material.AllDirtyFlag);
                                
                                // Âº∫Âà∂ÈáçÊñ∞ËÆ°ÁÆóÊâÄÊúâÁΩëÊ†º
                                this.scene.meshes.forEach(mesh => {
                                    if (mesh.geometry) {
                                        mesh.refreshBoundingInfo();
                                    }
                                });
                            }
                        }
                    }
                });
                
                // È¢ùÂ§ñÁöÑÊÄßËÉΩ‰ºòÂåñËÆæÁΩÆ
                if (this.enableHighPerformanceMode) {
                    // ÂêØÁî®ÂºïÊìéÊûÅÈôê‰ºòÂåñ
                    this.engine.enableOfflineSupport = false;
                    this.engine.doNotHandleContextLost = true;
                    
                    // ÂÆöÊúüÂº∫Âà∂ÂûÉÂúæÂõûÊî∂ÔºàÊéßÂà∂ÂÜÖÂ≠ò‰ª•ÊúÄÂ§ßÂåñGPUÂà©Áî®Ôºâ
                    setInterval(() => {
                        if (this.scene.getEngine().drawCalls > 500) {
                            this.scene.cleanCachedTextureBuffer();
                        }
                    }, 1000);
                    
                    console.log('üöÄ ÊûÅÈôêÊÄßËÉΩÊ∏≤ÊüìÂæ™ÁéØÂ∑≤ÂêØÂä® - GPUÂà©Áî®ÁéáÊúÄÂ§ßÂåñÊ®°Âºè');
                } else {
                    console.log('Ê†áÂáÜÊ∏≤ÊüìÂæ™ÁéØÂ∑≤ÂêØÂä®');
                }
            }

            dispose() {
                // Ê∏ÖÁêÜÊâÄÊúâÁªÑ‰ª∂
                this.components.forEach(comp => {
                    if (comp.mesh) {
                        comp.mesh.dispose();
                    }
                });
                
                // Ê∏ÖÁêÜÂÖâÁ∫ø
                this.rayLines.forEach(line => line.dispose());
                
                // Ê∏ÖÁêÜÂõûË∞É
                if (window.sliderCallbacks) {
                    window.sliderCallbacks = {};
                }
                if (window.colorCallbacks) {
                    window.colorCallbacks = {};
                }
                
                if (this.scene) {
                    this.scene.dispose();
                }
                if (this.engine) {
                    this.engine.dispose();
                }
            }
        }

        // ÂÖ®Â±ÄÂèòÈáè‰æõÊåâÈíÆË∞ÉÁî®
        let opticalSystemGame = null;

        // ÂàùÂßãÂåñÊ∏∏Êàè
        async function initializeGame() {
            try {
                console.log('ÂºÄÂßãÂàùÂßãÂåñÊ∏∏Êàè...');
                opticalSystemGame = new OpticalSystem();
            } catch (error) {
                console.error('Ê∏∏ÊàèÂàùÂßãÂåñÂ§±Ë¥•:', error);
                
                // ÊòæÁ§∫ÈîôËØØ‰ø°ÊÅØ
                const loadingScreen = document.getElementById('loadingScreen');
                if (loadingScreen) {
                    loadingScreen.innerHTML = `
                        <div style="color: #ff4444; text-align: center; padding: 20px;">
                            <h3>‚ùå ÂàùÂßãÂåñÂ§±Ë¥•</h3>
                            <p style="margin: 20px 0;">${error.message}</p>
                            <p style="font-size: 12px;">ÈîôËØØËØ¶ÊÉÖ: ${error.stack}</p>
                            <button onclick="location.reload()" style="padding: 10px 20px; background: #ff4444; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 10px;">
                                ÈáçÊñ∞Âä†ËΩΩ
                            </button>
                        </div>
                    `;
                }
            }
        }

        // Á≠âÂæÖÈ°µÈù¢ÂÆåÂÖ®Âä†ËΩΩÂêéÂàùÂßãÂåñ
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeGame);
        } else {
            initializeGame();
        }

        // Èò≤Ê≠¢È°µÈù¢Âà∑Êñ∞‰∏¢Â§±
        window.addEventListener('beforeunload', (event) => {
            if (opticalSystemGame && opticalSystemGame.components && opticalSystemGame.components.length > 0) {
                event.preventDefault();
                event.returnValue = 'ÊÇ®Á°ÆÂÆöË¶ÅÁ¶ªÂºÄÂêóÔºüÊú™‰øùÂ≠òÁöÑËÆæËÆ°Â∞Ü‰∏¢Â§±„ÄÇ';
            }
        });

        // ÂÖ®Â±ÄÈîôËØØÂ§ÑÁêÜ
        window.addEventListener('error', (event) => {
            console.error('JavaScriptÈîôËØØ:', event.error);
            
            // Â¶ÇÊûúÊòØÂàùÂßãÂåñÈò∂ÊÆµÁöÑÈîôËØØÔºåÊòæÁ§∫ÂèãÂ•ΩÊèêÁ§∫
            if (!opticalSystemGame || !opticalSystemGame.engine) {
                const loadingScreen = document.getElementById('loadingScreen');
                if (loadingScreen && !loadingScreen.classList.contains('hidden')) {
                    loadingScreen.innerHTML = `
                        <div style="color: #ff4444; text-align: center; padding: 20px;">
                            <h3>‚ùå ÂèëÁîüÈîôËØØ</h3>
                            <p style="margin: 20px 0;">Á®ãÂ∫èÂàùÂßãÂåñÂ§±Ë¥•ÔºåËØ∑Âà∑Êñ∞È°µÈù¢ÈáçËØï„ÄÇ</p>
                            <p style="font-size: 12px; color: #ccc;">ËØ¶ÁªÜÈîôËØØ‰ø°ÊÅØËØ∑Êü•ÁúãÊµèËßàÂô®ÊéßÂà∂Âè∞</p>
                        </div>
                    `;
                }
            }
        });

        </script>
    </body>
    </html>