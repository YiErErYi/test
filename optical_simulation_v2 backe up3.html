<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3Då…‰å­¦ç³»ç»Ÿè®¾è®¡æ¸¸æˆ - å¢å¼ºç‰ˆ</title>
    <!-- Babylon.js æ ¸å¿ƒåº“ -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <!-- Babylon.js åŠ è½½å™¨ -->
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <!-- Babylon.js GUI -->
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <!-- æè´¨åº“ -->
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
            outline: none;
            touch-action: none;
        }

        #uiPanel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 340px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            z-index: 100;
        }

        .panel {
            background: rgba(0, 20, 40, 0.9);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 8px 32px rgba(0, 255, 255, 0.2);
        }

        .panel h3 {
            color: #00ffff;
            margin-bottom: 10px;
            text-align: center;
            font-size: 16px;
            text-shadow: 0 0 10px #00ffff;
        }

        .component-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .component-btn {
            background: linear-gradient(45deg, #0a1a2a, #1a3a5a);
            border: 1px solid #00aacc;
            border-radius: 8px;
            padding: 10px 5px;
            color: #ffffff;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            display: -webkit-flex; /* Safari 6.1+ */
            display: flex;
            -webkit-flex-direction: column; /* Safari 6.1+ */
            flex-direction: column;
            -webkit-align-items: center; /* Safari 7.1+ */
            align-items: center;
            gap: 5px;
            -webkit-user-select: none; /* Safari 3+ */
            user-select: none;
        }

        .component-btn:hover {
            background: linear-gradient(45deg, #1a3a5a, #2a4a6a);
            border-color: #00ffff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            -webkit-transform: translateY(-2px); /* Safari 3.1+ */
            transform: translateY(-2px);
        }

        .component-btn.selected {
            background: linear-gradient(45deg, #00aacc, #0088aa);
            border-color: #ffffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
        }

        .component-btn .icon {
            font-size: 20px;
            line-height: 1;
        }

        .component-btn span {
            font-size: 11px;
            font-weight: bold;
        }

        #propertyControls {
            color: #ffffff;
            min-height: 60px;
        }

        .property-group {
            margin-bottom: 15px;
        }

        .property-group label {
            display: block;
            margin-bottom: 5px;
            color: #00ccff;
            font-size: 12px;
            font-weight: bold;
        }

        .property-group input,
        .property-group select {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #00aacc;
            border-radius: 4px;
            background: rgba(0, 50, 100, 0.7);
            color: #ffffff;
            font-size: 12px;
        }

        .property-group input:focus,
        .property-group select:focus {
            outline: none;
            border-color: #00ffff;
            box-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
        }

        .property-group button {
            width: 100%;
            padding: 8px;
            background: linear-gradient(45deg, #cc3300, #ff4400);
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            margin-top: 5px;
        }

        .property-group button:hover {
            background: linear-gradient(45deg, #ff4400, #ff6600);
            box-shadow: 0 0 10px rgba(255, 68, 0, 0.5);
        }

        .prop-slider {
            display: -webkit-flex; /* Safari 6.1+ */
            display: flex;
            -webkit-align-items: center; /* Safari 7.1+ */
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .prop-slider label {
            min-width: 90px;
            font-size: 11px;
            margin-bottom: 0;
        }

        .prop-slider input[type="range"] {
            -webkit-flex: 1; /* Safari 6.1+ */
            flex: 1;
            height: 20px;
        }

        .prop-slider input[type="number"] {
            width: 70px;
            padding: 2px 4px;
            font-size: 11px;
        }

        .prop-color {
            display: -webkit-flex; /* Safari 6.1+ */
            display: flex;
            -webkit-align-items: center; /* Safari 7.1+ */
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .prop-color label {
            min-width: 90px;
            font-size: 11px;
            margin-bottom: 0;
        }

        .prop-color input[type="color"] {
            width: 40px;
            height: 25px;
            border: none;
            border-radius: 4px;
        }

        #systemInfo {
            color: #ffffff;
            font-size: 12px;
            line-height: 1.4;
        }

        #systemInfo div {
            margin-bottom: 8px;
            padding: 5px;
            background: rgba(0, 100, 150, 0.3);
            border-radius: 4px;
            border-left: 3px solid #00ffff;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 20, 40, 0.9);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 15px;
            color: #ffffff;
            box-shadow: 0 8px 32px rgba(0, 255, 255, 0.2);
            max-width: 250px;
        }

        #controls h4 {
            color: #00ffff;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #00ffff;
        }

        #controls p {
            margin-bottom: 5px;
            font-size: 12px;
        }

        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            display: -webkit-flex; /* Safari 6.1+ */
            display: flex;
            -webkit-justify-content: center; /* Safari 7.1+ */
            justify-content: center;
            -webkit-align-items: center; /* Safari 7.1+ */
            align-items: center;
            z-index: 9999;
            color: white;
            text-align: center;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #00ffff;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { 
                -webkit-transform: rotate(0deg); /* Safari 3.1+ */
                transform: rotate(0deg); 
            }
            100% { 
                -webkit-transform: rotate(360deg); /* Safari 3.1+ */
                transform: rotate(360deg); 
            }
        }

        .hidden {
            display: none !important;
        }

        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 50, 100, 0.3);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb {
            background: #00aacc;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #00ffff;
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <div>
            <div class="spinner"></div>
            <p>æ­£åœ¨åŠ è½½3Då…‰å­¦ç³»ç»Ÿ...</p>
        </div>
    </div>

    <div id="gameContainer" class="hidden">
        <canvas id="renderCanvas"></canvas>
        
        <!-- UIé¢æ¿ -->
        <div id="uiPanel">
            <div id="componentPanel" class="panel">
                <h3>å…‰å­¦ç»„ä»¶</h3>
                <div class="component-grid">
                    <button class="component-btn" data-type="laser">
                        <div class="icon">ğŸ’¡</div>
                        <span>æ¿€å…‰æº</span>
                    </button>
                    <button class="component-btn" data-type="lens" data-subtype="convex">
                        <div class="icon">ğŸ”</div>
                        <span>é€é•œ</span>
                    </button>
                    <button class="component-btn" data-type="mirror" data-subtype="plane">
                        <div class="icon">ğŸª</div>
                        <span>å¹³é¢é•œ</span>
                    </button>
                    <button class="component-btn" data-type="mirror" data-subtype="concave">
                        <div class="icon">ğŸŒ™</div>
                        <span>å‡¹é¢é•œ</span>
                    </button>
                    <button class="component-btn" data-type="prism">
                        <div class="icon">ğŸ”º</div>
                        <span>ä¸‰æ£±é•œ</span>
                    </button>
                    <button class="component-btn" data-type="grating">
                        <div class="icon">â–¤</div>
                        <span>è¡å°„å…‰æ …</span>
                    </button>
                    <button class="component-btn" data-type="screen">
                        <div class="icon">ğŸ–¥ï¸</div>
                        <span>å±å¹•</span>
                    </button>
                </div>
            </div>

            <div id="propertiesPanel" class="panel">
                <h3>ç»„ä»¶å±æ€§</h3>
                <div id="propertyControls">
                    <p>é€‰æ‹©ä¸€ä¸ªç»„ä»¶æ¥ç¼–è¾‘å±æ€§</p>
                </div>
            </div>

            <div id="infoPanel" class="panel">
                <h3>ç³»ç»Ÿä¿¡æ¯</h3>
                <div id="systemInfo">
                    <div id="distanceInfo">è·ç¦»ä¿¡æ¯: ç­‰å¾…ç»„ä»¶æ·»åŠ </div>
                    <div id="rayInfo">å…‰çº¿ä¿¡æ¯: 0æ¡å…‰çº¿</div>
                    <div id="performanceInfo">æ€§èƒ½ä¿¡æ¯: æ­£åœ¨åˆå§‹åŒ–...</div>
                </div>
                
                <!-- æ€§èƒ½æ§åˆ¶é¢æ¿ -->
                <div style="margin-top: 15px; padding: 8px; background: rgba(255, 100, 0, 0.1); border-radius: 4px; border: 1px solid #ff6400;">
                    <h4 style="margin: 0 0 8px 0; color: #ff6400;">ğŸ”¥ æé™æ€§èƒ½æ¨¡å¼</h4>
                    <div style="font-size: 11px;">
                        <label><input type="checkbox" id="realtimeRayTracing" checked> å®æ—¶å…‰çº¿è¿½è¸ª</label><br>
                        <label><input type="checkbox" id="forceRender" checked> å¼ºåˆ¶æ¯å¸§æ¸²æŸ“</label><br>
                        <label><input type="checkbox" id="advancedRayTracing" checked> é«˜çº§å…‰çº¿è¿½è¸ª</label><br>
                        <label><input type="checkbox" id="maxGpuLoad" checked> æœ€å¤§GPUè´Ÿè½½</label><br>
                        <div style="margin-top: 5px;">
                            <label>å…‰çº¿å¯†åº¦: <input type="range" id="rayDensity" min="1" max="10" value="3" style="width: 60px;"></label>
                            <span id="rayDensityValue">3</span>
                        </div>
                        <div>
                            <label>æœ€å¤§åå¼¹: <input type="range" id="maxBounces" min="10" max="200" value="100" style="width: 60px;"></label>
                            <span id="maxBouncesValue">100</span>
                        </div>
                        <div>
                            <label>æ¸²æŸ“åˆ†è¾¨ç‡: <input type="range" id="renderScale" min="50" max="200" value="100" style="width: 60px;"></label>
                            <span id="renderScaleValue">100%</span>
                        </div>
                        <div>
                            <label>ç›®æ ‡FPS: <input type="range" id="targetFps" min="30" max="240" value="144" style="width: 60px;"></label>
                            <span id="targetFpsValue">144</span>
                        </div>
                        <div style="margin-top: 5px;">
                            <button id="forceGpuStress" style="padding: 2px 6px; font-size: 10px; background: #ff4444; color: white; border: none; border-radius: 2px; cursor: pointer;">
                                ğŸ”¥ GPUå‹åŠ›æµ‹è¯•
                            </button>
                            <button id="optimizeMemory" style="padding: 2px 6px; font-size: 10px; background: #44ff44; color: black; border: none; border-radius: 2px; cursor: pointer; margin-left: 4px;">
                                ğŸ§¹ å†…å­˜ä¼˜åŒ–
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- æ§åˆ¶è¯´æ˜ -->
        <div id="controls">
            <h4>æ§åˆ¶è¯´æ˜</h4>
            <p> é¼ æ ‡å·¦é”®: é€‰æ‹©ç»„ä»¶</p>
            <p> é¼ æ ‡æ‹–æ‹½: æ—‹è½¬è§†è§’</p>
            <p>ğŸ”„ T/Ré”®: åˆ‡æ¢ç§»åŠ¨/æ—‹è½¬æ¨¡å¼</p>
            <p>â¬†ï¸â¬‡ï¸ æ–¹å‘é”®: å¾®è°ƒä½ç½®</p>
            <p>ğŸ” é¼ æ ‡æ»šè½®: ç¼©æ”¾è§†å›¾</p>
            <p>ğŸ—‘ï¸ Delé”®: åˆ é™¤é€‰ä¸­ç»„ä»¶</p>
            <p>âŒ¨ï¸ Escé”®: å–æ¶ˆé€‰æ‹©</p>
            <p style="color: #ff6400;">âš¡ å®æ—¶æ¸²æŸ“æ¨¡å¼å·²å¯ç”¨</p>
        </div>
    </div>

    <script>
        // ç­‰å¾…Babylon.jsåŠ è½½å®Œæˆ
        function waitForBabylon() {
            return new Promise((resolve, reject) => {
                let attempts = 0;
                const maxAttempts = 100;
                
                function check() {
                    attempts++;
                    console.log(`æ£€æŸ¥Babylon.jsåŠ è½½çŠ¶æ€: ${attempts}/${maxAttempts}`);
                    
                    if (typeof BABYLON !== 'undefined' && 
                        BABYLON.Engine && 
                        BABYLON.Scene && 
                        BABYLON.ArcRotateCamera &&
                        BABYLON.Vector3) {
                        console.log('Babylon.js åŠ è½½å®Œæˆ');
                        resolve();
                    } else if (attempts >= maxAttempts) {
                        reject(new Error('Babylon.js åŠ è½½è¶…æ—¶'));
                    } else {
                        setTimeout(check, 100);
                    }
                }
                
                check();
            });
        }

        class OpticalSystem {
            constructor() {
                this.canvas = null;
                this.engine = null;
                this.scene = null;
                this.camera = null;
                this.gizmoManager = null;
                this.selectedComponent = null;
                this.components = [];
                this.rayLines = [];
                this.maxBounces = 100; // é»˜è®¤æ›´é«˜çš„åå¼¹æ¬¡æ•°
                this.needsRayUpdate = true;
                this.lastRayUpdateTime = 0;
                this.rayUpdateInterval = 0; // è®¾ç½®ä¸º0ï¼Œå®æ—¶æ›´æ–°å…‰çº¿è¿½è¸ª
                this.transformMode = 'translate'; // é»˜è®¤ç§»åŠ¨æ¨¡å¼
                
                // ç®€å•æ‹–æ‹½å˜é‡
                this.isDragging = false;
                this.dragStartPoint = null;
                this.dragStartObjectPosition = null;
                
                // æ€§èƒ½ä¼˜åŒ–å˜é‡
                this.enableRealtimeRayTracing = true; // å¯ç”¨å®æ—¶å…‰çº¿è¿½è¸ª
                this.rayDensity = 3; // é»˜è®¤å…‰çº¿å¯†åº¦
                this.maxGpuLoad = true; // é»˜è®¤å¯ç”¨æœ€å¤§GPUè´Ÿè½½
                this.targetFPS = 144; // ç›®æ ‡FPS
                this.gpuStressObjects = null; // GPUå‹åŠ›æµ‹è¯•å¯¹è±¡
                this.enableHighPerformanceMode = true; // å¯ç”¨é«˜æ€§èƒ½æ¨¡å¼
                this.maxFPS = 0; // 0è¡¨ç¤ºä¸é™åˆ¶FPS
                this.forceRender = true; // å¼ºåˆ¶æ¯å¸§æ¸²æŸ“
                this.maxBounces = 50; // å¢åŠ æœ€å¤§åå¼¹æ¬¡æ•°ä»¥è·å¾—æ›´ç²¾ç¡®çš„å…‰çº¿è¿½è¸ª
                this.rayDensity = 1; // å…‰çº¿å¯†åº¦ï¼ˆå¯ä»¥å¢åŠ ä»¥è·å¾—æ›´å¤šå…‰çº¿ï¼‰
                this.enableAdvancedRayTracing = true; // å¯ç”¨é«˜çº§å…‰çº¿è¿½è¸ª
                
                console.log('å¼€å§‹åˆå§‹åŒ–å…‰å­¦ç³»ç»Ÿ...');
                this.init();
            }

            async init() {
                try {                    // ç­‰å¾…Babylon.jså®Œå…¨åŠ è½½
                    await waitForBabylon();
                    
                    // ç­‰å¾…DOMå®Œå…¨åŠ è½½
                    if (document.readyState !== 'complete') {
                        await new Promise(resolve => window.addEventListener('load', resolve));
                    }

                    console.log('è·å–ç”»å¸ƒå…ƒç´ ...');
                    this.canvas = document.getElementById('renderCanvas');
                    if (!this.canvas) {
                        throw new Error('æ— æ³•æ‰¾åˆ°ç”»å¸ƒå…ƒç´ ');
                    }

                    console.log('åˆ›å»ºBabylon.jså¼•æ“...');
                    // å¼ºåˆ¶å¯ç”¨ç‹¬ç«‹GPUå’Œæœ€å¤§æ€§èƒ½é…ç½®
                    this.engine = new BABYLON.Engine(this.canvas, true, {
                        preserveDrawingBuffer: false, // ç¦ç”¨ä»¥èŠ‚çœæ˜¾å­˜
                        stencil: true,
                        depth: true,
                        powerPreference: "high-performance", // å¼ºåˆ¶é«˜æ€§èƒ½GPU
                        antialias: false, // å…³é—­æŠ—é”¯é½¿ä»¥æœ€å¤§åŒ–æ€§èƒ½
                        adaptToDeviceRatio: false, // ç¦ç”¨è®¾å¤‡åƒç´ æ¯”é€‚é…
                        premultipliedAlpha: false,
                        doNotHandleContextLost: true,
                        audioEngine: false, // ç¦ç”¨éŸ³é¢‘å¼•æ“
                        deterministicLockstep: false, // ç¦ç”¨é”æ­¥
                        lockstepMaxSteps: 1,
                        useHighPrecisionMatrix: true,
                        failIfMajorPerformanceCaveat: false, // å…è®¸è½¯ä»¶æ¸²æŸ“
                        xrCompatible: false, // ç¦ç”¨VRå…¼å®¹
                        desynchronized: true, // å¯ç”¨å¼‚æ­¥æ¸²æŸ“
                        alpha: false, // ç¦ç”¨é€æ˜åº¦ä»¥æå‡æ€§èƒ½
                        // WebGL2å¼ºåˆ¶å¯ç”¨
                        webglVersion: 2,
                        // æœ€å¤§æ˜¾å­˜å’ŒGPUåˆ©ç”¨ç‡è®¾ç½®
                        forcedExtensions: ['WEBGL_lose_context', 'OES_texture_float', 'WEBGL_depth_texture']
                    });

                    // è®¾ç½®å¼•æ“ä¸ºæé™æ€§èƒ½æ¨¡å¼
                    if (this.enableHighPerformanceMode) {
                        // å¼ºåˆ¶æœ€é«˜ç¡¬ä»¶åŠ é€Ÿ
                        this.engine.setHardwareScalingLevel(0.5); // é™ä½åˆ†è¾¨ç‡ä»¥æœ€å¤§åŒ–å¸§ç‡
                        this.engine.disableOfflineSupport = true;
                        this.engine.enableOfflineSupport = false;
                        
                        // å¼ºåˆ¶è®¾ç½®é«˜åˆ·æ–°ç‡å’Œæœ€å¤§æ˜¾å­˜ä½¿ç”¨
                        this.engine.setSize(window.innerWidth, window.innerHeight, false);
                        
                        // WebGLçŠ¶æ€ä¼˜åŒ–
                        const gl = this.engine._gl;
                        if (gl) {
                            // ç¦ç”¨æ·±åº¦å†™å…¥ä¼˜åŒ–ï¼ˆåœ¨ä¸éœ€è¦æ—¶ï¼‰
                            gl.disable(gl.DITHER);
                            // å¯ç”¨ç¡¬ä»¶ä¼˜åŒ–
                            gl.hint(gl.FRAGMENT_SHADER_DERIVATIVE_HINT, gl.FASTEST);
                            // æœ€å¤§åŒ–çº¹ç†å•å…ƒä½¿ç”¨
                            console.log('WebGLæœ€å¤§çº¹ç†å•å…ƒ:', gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS));
                        }
                        
                        // å¼ºåˆ¶å‚ç›´åŒæ­¥å…³é—­ï¼ˆå¦‚æœå¯èƒ½ï¼‰
                        this.canvas.style.imageRendering = 'pixelated'; // ç¦ç”¨å›¾åƒå¹³æ»‘
                        
                        console.log('ğŸ”¥ æé™æ€§èƒ½æ¨¡å¼å·²å¯ç”¨ - GPUåŠ é€Ÿæœ€å¤§åŒ–');
                    }

                    if (!this.engine) {
                        throw new Error('æ— æ³•åˆ›å»ºBabylon.jså¼•æ“');
                    }

                    console.log('åˆ›å»ºåœºæ™¯...');
                    this.createScene();
                    
                    console.log('åˆ›å»ºç›¸æœº...');
                    await this.createCamera();
                    
                    console.log('åˆ›å»ºå…‰ç…§...');
                    this.createLighting();
                    
                    console.log('åˆ›å»ºç¯å¢ƒ...');
                    this.createEnvironment();
                    
                    console.log('è®¾ç½®Gizmoç®¡ç†å™¨...');
                    this.setupGizmoManager();
                    
                    // ğŸ”¥ æé™æ€§èƒ½ä¼˜åŒ–è®¾ç½®
                    this.setupExtremePerformanceMode();
                    
                    console.log('è®¾ç½®äº‹ä»¶ç›‘å¬å™¨...');
                    this.setupEventListeners();
                    
                    console.log('å¯åŠ¨æ¸²æŸ“å¾ªç¯...');
                    this.startRenderLoop();
                    
                    // éšè—åŠ è½½å±å¹•
                    document.getElementById('loadingScreen').classList.add('hidden');
                    document.getElementById('gameContainer').classList.remove('hidden');
                    
                    console.log('å…‰å­¦ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ!');
                    
                } catch (error) {
                    console.error('åˆå§‹åŒ–å¤±è´¥:', error);
                    this.showError(error.message);
                }
            }

            showError(message) {
                const loadingScreen = document.getElementById('loadingScreen');
                if (loadingScreen) {
                    loadingScreen.innerHTML = `
                        <div style="color: #ff4444; text-align: center; padding: 20px;">
                            <h3>âŒ åˆå§‹åŒ–å¤±è´¥</h3>
                            <p style="margin: 20px 0;">${message}</p>
                            <p style="font-size: 12px; margin: 10px 0;">è¯·æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒWebGL</p>
                            <button onclick="location.reload()" style="padding: 10px 20px; background: #ff4444; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 10px;">
                                é‡æ–°åŠ è½½
                            </button>
                        </div>
                    `;
                }
            }

            createScene() {
                this.scene = new BABYLON.Scene(this.engine);
                this.scene.clearColor = new BABYLON.Color3(0.1, 0.1, 0.15);
                
                // æ€§èƒ½ä¼˜åŒ–è®¾ç½®
                if (this.enableHighPerformanceMode) {
                    this.scene.skipPointerMovePicking = false; // ä¿æŒç²¾ç¡®çš„é¼ æ ‡æ‹¾å–
                    this.scene.autoClear = true; // å¯ç”¨è‡ªåŠ¨æ¸…é™¤
                    this.scene.autoClearDepthAndStencil = true; // å¯ç”¨æ·±åº¦å’Œæ¨¡æ¿è‡ªåŠ¨æ¸…é™¤
                    this.scene.blockMaterialDirtyMechanism = false; // å¯ç”¨æè´¨è„æ£€æŸ¥æœºåˆ¶
                    this.scene.useDelayedTextureLoading = false; // ç¦ç”¨å»¶è¿Ÿçº¹ç†åŠ è½½ä»¥è·å¾—æ›´å¥½çš„å“åº”æ€§
                    this.scene.probesEnabled = true; // å¯ç”¨æ¢é’ˆ
                    this.scene.lightsEnabled = true; // ç¡®ä¿å…‰ç…§å¯ç”¨
                    this.scene.shadowsEnabled = true; // å¯ç”¨é˜´å½±
                    this.scene.particlesEnabled = true; // å¯ç”¨ç²’å­ç³»ç»Ÿ
                    this.scene.spritesEnabled = false; // ç¦ç”¨ç²¾çµä»¥èŠ‚çœæ€§èƒ½
                    this.scene.skeletonsEnabled = false; // ç¦ç”¨éª¨éª¼åŠ¨ç”»ä»¥èŠ‚çœæ€§èƒ½
                    this.scene.lensFlaresEnabled = false; // ç¦ç”¨é•œå¤´å…‰æ™•ä»¥èŠ‚çœæ€§èƒ½
                    this.scene.collisionsEnabled = false; // ç¦ç”¨ç¢°æ’æ£€æµ‹ä»¥èŠ‚çœæ€§èƒ½
                    this.scene.physicsEnabled = false; // ç¦ç”¨ç‰©ç†å¼•æ“ä»¥èŠ‚çœæ€§èƒ½
                    this.scene.fogEnabled = false; // ç¦ç”¨é›¾æ•ˆä»¥èŠ‚çœæ€§èƒ½
                    
                    // ä¼˜åŒ–æ¸²æŸ“æ€§èƒ½
                    this.scene.freezeActiveMeshes = false; // ä¸å†»ç»“æ´»åŠ¨ç½‘æ ¼ï¼Œä¿æŒåŠ¨æ€æ›´æ–°
                    this.scene.constantlyUpdateMeshUnderPointer = true; // æŒç»­æ›´æ–°é¼ æ ‡ä¸‹çš„ç½‘æ ¼
                    
                    console.log('åœºæ™¯æ€§èƒ½ä¼˜åŒ–å·²å¯ç”¨');
                }
                
                console.log('åœºæ™¯åˆ›å»ºæˆåŠŸ');
            }

            async createCamera() {
                try {
                    console.log('åˆ›å»ºå¼§å½¢æ—‹è½¬ç›¸æœº...');
                    
                    this.camera = new BABYLON.ArcRotateCamera(
                        "camera",
                        -Math.PI / 2,
                        Math.PI / 2.5,
                        20,
                        BABYLON.Vector3.Zero(),
                        this.scene
                    );

                    // ç»Ÿä¸€ä½¿ç”¨attachControlæ–¹æ³•
                    this.camera.attachControl(this.canvas, true);
                    
                    this.camera.setTarget(BABYLON.Vector3.Zero());
                    
                    // è®¾ç½®ç›¸æœºé™åˆ¶
                    this.camera.lowerRadiusLimit = 5;
                    this.camera.upperRadiusLimit = 50;
                    this.camera.lowerBetaLimit = 0.1;
                    this.camera.upperBetaLimit = Math.PI / 2;
                    
                    console.log('ç›¸æœºè®¾ç½®å®Œæˆ');
                } catch (error) {
                    console.error('ç›¸æœºåˆ›å»ºå¤±è´¥:', error);
                    throw new Error('æ— æ³•åˆ›å»ºç›¸æœº');
                }
            }

            createLighting() {
                const light = new BABYLON.HemisphericLight(
                    "light", 
                    new BABYLON.Vector3(0, 1, 0), 
                    this.scene
                );
                light.intensity = 0.8;
                
                // æ·»åŠ å®šå‘å…‰ä»¥å¢å¼ºæ•ˆæœ
                const dirLight = new BABYLON.DirectionalLight(
                    "dirLight",
                    new BABYLON.Vector3(-1, -2, -1),
                    this.scene
                );
                dirLight.intensity = 0.5;
                
                console.log('å…‰ç…§åˆ›å»ºæˆåŠŸ');
            }

            createEnvironment() {
                try {
                    // åˆ›å»ºå…‰å­¦å¹³å°
                    const ground = BABYLON.MeshBuilder.CreateGround(
                        "ground", 
                        {width: 20, height: 20}, 
                        this.scene
                    );
                    
                    // åˆ›å»ºç½‘æ ¼æè´¨
                    const groundMaterial = new BABYLON.StandardMaterial("groundMat", this.scene);
                    groundMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.25);
                    groundMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
                    
                    // æ·»åŠ ç½‘æ ¼çº¹ç†æ•ˆæœ
                    const groundTexture = new BABYLON.DynamicTexture("groundTexture", {width: 512, height: 512}, this.scene);
                    const ctx = groundTexture.getContext();
                    
                    // ç»˜åˆ¶ç½‘æ ¼
                    ctx.fillStyle = "#333344";
                    ctx.fillRect(0, 0, 512, 512);
                    ctx.strokeStyle = "#445566";
                    ctx.lineWidth = 1;
                    
                    for (let i = 0; i <= 512; i += 32) {
                        ctx.beginPath();
                        ctx.moveTo(i, 0);
                        ctx.lineTo(i, 512);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(0, i);
                        ctx.lineTo(512, i);
                        ctx.stroke();
                    }
                    
                    groundTexture.update();
                    groundMaterial.diffuseTexture = groundTexture;
                    ground.material = groundMaterial;
                    ground.isPickable = false;
                    
                    console.log('ç¯å¢ƒåˆ›å»ºæˆåŠŸ');
                } catch (error) {
                    console.error('ç¯å¢ƒåˆ›å»ºå¤±è´¥:', error);
                }
            }

            setupGizmoManager() {
                try {
                    if (BABYLON.GizmoManager) {
                        this.gizmoManager = new BABYLON.GizmoManager(this.scene);
                        this.gizmoManager.positionGizmoEnabled = true;
                        this.gizmoManager.rotationGizmoEnabled = false; // é»˜è®¤å…³é—­æ—‹è½¬
                        this.gizmoManager.scaleGizmoEnabled = false;
                        this.gizmoManager.usePointerToAttachGizmos = false;

                        // ç­‰å¾…Gizmoåˆå§‹åŒ–å®Œæˆ
                        setTimeout(() => {
                            try {
                                // æ£€æŸ¥Gizmoæ˜¯å¦å¯ç”¨
                                if (this.gizmoManager.gizmos && 
                                    this.gizmoManager.gizmos.positionGizmo && 
                                    this.gizmoManager.gizmos.rotationGizmo) {
                                    
                                    // ç›‘å¬ä½ç½®Gizmoæ‹–æ‹½äº‹ä»¶
                                    this.gizmoManager.gizmos.positionGizmo.onDragStartObservable.add(() => {
                                        this.camera.detachControl();
                                        console.log('å¼€å§‹æ‹–æ‹½ä½ç½®Gizmo');
                                    });

                                    this.gizmoManager.gizmos.positionGizmo.onDragEndObservable.add(() => {
                                        this.camera.attachControl(this.canvas, true);
                                        this.needsRayUpdate = true;
                                        this.updatePropertiesPanel(); // æ›´æ–°å±æ€§é¢æ¿æ˜¾ç¤º
                                        console.log('ç»“æŸæ‹–æ‹½ä½ç½®Gizmo');
                                    });

                                    // ç›‘å¬æ—‹è½¬Gizmoæ‹–æ‹½äº‹ä»¶
                                    this.gizmoManager.gizmos.rotationGizmo.onDragStartObservable.add(() => {
                                        this.camera.detachControl();
                                        console.log('å¼€å§‹æ‹–æ‹½æ—‹è½¬Gizmo');
                                    });

                                    this.gizmoManager.gizmos.rotationGizmo.onDragEndObservable.add(() => {
                                        this.camera.attachControl(this.canvas, true);
                                        this.needsRayUpdate = true;
                                        this.updatePropertiesPanel(); // æ›´æ–°å±æ€§é¢æ¿æ˜¾ç¤º
                                        console.log('ç»“æŸæ‹–æ‹½æ—‹è½¬Gizmo');
                                    });

                                    // æ·»åŠ å®æ—¶å˜æ¢ç›‘å¬
                                    this.gizmoManager.gizmos.positionGizmo.onDragObservable.add(() => {
                                        this.needsRayUpdate = true;
                                    });

                                    this.gizmoManager.gizmos.rotationGizmo.onDragObservable.add(() => {
                                        this.needsRayUpdate = true;
                                    });
                                    
                                    console.log('Gizmoäº‹ä»¶ç›‘å¬å™¨è®¾ç½®æˆåŠŸ');
                                } else {
                                    console.warn('Gizmoå¯¹è±¡æœªæ­£ç¡®åˆå§‹åŒ–');
                                }
                            } catch (delayedError) {
                                console.error('å»¶è¿ŸGizmoè®¾ç½®å¤±è´¥:', delayedError);
                            }
                        }, 100); // å»¶è¿Ÿ100msç­‰å¾…Gizmoåˆå§‹åŒ–
                        
                        console.log('Gizmoç®¡ç†å™¨åˆ›å»ºæˆåŠŸ');
                    } else {
                        console.warn('BABYLON.GizmoManager ä¸å¯ç”¨ï¼Œè·³è¿‡Gizmoè®¾ç½®');
                    }
                } catch (error) {
                    console.error('Gizmoç®¡ç†å™¨è®¾ç½®å¤±è´¥:', error);
                    this.gizmoManager = null;
                }
            }

            // è®¾ç½®å˜æ¢æ¨¡å¼
            setTransformMode(mode) {
                if (!this.gizmoManager) {
                    console.warn('GizmoManager æœªåˆå§‹åŒ–');
                    return;
                }
                
                this.transformMode = mode;
                
                try {
                    if (mode === 'translate') {
                        this.gizmoManager.positionGizmoEnabled = true;
                        this.gizmoManager.rotationGizmoEnabled = false;
                        console.log('åˆ‡æ¢åˆ°ç§»åŠ¨æ¨¡å¼');
                    } else if (mode === 'rotate') {
                        this.gizmoManager.positionGizmoEnabled = false;
                        this.gizmoManager.rotationGizmoEnabled = true;
                        console.log('åˆ‡æ¢åˆ°æ—‹è½¬æ¨¡å¼');
                    }
                    
                    // å¦‚æœæœ‰é€‰ä¸­çš„ç»„ä»¶ï¼Œé‡æ–°é™„åŠ Gizmoä»¥åº”ç”¨æ–°æ¨¡å¼
                    if (this.selectedComponent) {
                        console.log('é‡æ–°é™„åŠ Gizmoåˆ°é€‰ä¸­ç»„ä»¶');
                        // å…ˆåˆ†ç¦»å†é‡æ–°é™„åŠ ï¼Œç¡®ä¿æ–°æ¨¡å¼ç”Ÿæ•ˆ
                        this.gizmoManager.attachToMesh(null);
                        setTimeout(() => {
                            if (this.selectedComponent) {
                                this.gizmoManager.attachToMesh(this.selectedComponent.mesh);
                            }
                        }, 50);
                    }
                } catch (error) {
                    console.error('è®¾ç½®å˜æ¢æ¨¡å¼å¤±è´¥:', error);
                }
            }

            setupEventListeners() {
                // é”®ç›˜äº‹ä»¶
                document.addEventListener('keydown', (event) => {
                    switch(event.key) {
                        case 'Escape':
                            event.preventDefault();
                            this.clearSelection();
                            break;
                        case 't':
                        case 'T':
                            event.preventDefault();
                            this.setTransformMode('translate');
                            break;
                        case 'r':
                        case 'R':
                            event.preventDefault();
                            this.setTransformMode('rotate');
                            break;
                        case 'Delete':
                        case 'Backspace':
                            event.preventDefault();
                            this.removeSelectedComponent();
                            break;
                    }

                    // å¾®è°ƒç§»åŠ¨ï¼ˆä¿ç•™åŸæœ‰åŠŸèƒ½ï¼‰
                    if (this.selectedComponent) {
                        const moveSpeed = event.shiftKey ? 0.5 : 0.1;
                        switch (event.key) {
                            case 'ArrowUp':
                                event.preventDefault();
                                this.selectedComponent.mesh.position.z += moveSpeed;
                                this.needsRayUpdate = true;
                                break;
                            case 'ArrowDown':
                                event.preventDefault();
                                this.selectedComponent.mesh.position.z -= moveSpeed;
                                this.needsRayUpdate = true;
                                break;
                            case 'ArrowLeft':
                                event.preventDefault();
                                this.selectedComponent.mesh.position.x -= moveSpeed;
                                this.needsRayUpdate = true;
                                break;
                            case 'ArrowRight':
                                event.preventDefault();
                                this.selectedComponent.mesh.position.x += moveSpeed;
                                this.needsRayUpdate = true;
                                break;
                        }
                    }
                });

                // é¼ æ ‡ç‚¹å‡»é€‰æ‹©å’Œæ‹–æ‹½
                this.scene.onPointerDown = (evt, pickInfo) => {
                    console.log('é¼ æ ‡ç‚¹å‡»æ£€æµ‹åˆ°ï¼ŒpickInfo:', pickInfo);
                    
                    if (pickInfo && pickInfo.hit) {
                        console.log('ç‚¹å‡»åˆ°å¯¹è±¡:', pickInfo.pickedMesh?.name);
                        const component = this.components.find(comp => comp.mesh === pickInfo.pickedMesh);
                        console.log('æ‰¾åˆ°çš„ç»„ä»¶:', component?.type);
                        
                        if (component) {
                            console.log('é€‰æ‹©ç»„ä»¶:', component.type);
                            this.selectComponent(component);
                            
                            // å¦‚æœGizmoä¸å¯ç”¨ï¼Œå¯ç”¨ç®€å•æ‹–æ‹½
                            if (!this.gizmoManager && evt.button === 0) { // å·¦é”®
                                this.isDragging = true;
                                this.dragStartPoint = this.getGroundPickPoint(evt);
                                this.dragStartObjectPosition = component.mesh.position.clone();
                                this.camera.detachControl();
                                console.log('å¼€å§‹ç®€å•æ‹–æ‹½æ¨¡å¼');
                            }
                        } else {
                            console.log('æœªæ‰¾åˆ°å¯¹åº”çš„ç»„ä»¶ï¼Œæ¸…é™¤é€‰æ‹©');
                            this.clearSelection();
                        }
                    } else {
                        console.log('æœªç‚¹å‡»åˆ°ä»»ä½•å¯¹è±¡ï¼Œæ¸…é™¤é€‰æ‹©');
                        this.clearSelection();
                    }
                };

                // é¼ æ ‡ç§»åŠ¨äº‹ä»¶
                this.scene.onPointerMove = (evt) => {
                    if (this.isDragging && this.selectedComponent && this.dragStartPoint) {
                        const currentPoint = this.getGroundPickPoint(evt);
                        if (currentPoint) {
                            const offset = currentPoint.subtract(this.dragStartPoint);
                            this.selectedComponent.mesh.position = this.dragStartObjectPosition.add(offset);
                            this.needsRayUpdate = true;
                        }
                    }
                };

                // é¼ æ ‡é‡Šæ”¾äº‹ä»¶
                this.scene.onPointerUp = (evt) => {
                    if (this.isDragging) {
                        this.isDragging = false;
                        this.camera.attachControl(this.canvas, true);
                        this.updatePropertiesPanel();
                        console.log('ç»“æŸç®€å•æ‹–æ‹½æ¨¡å¼');
                    }
                };

                // é¢å¤–çš„ç‚¹å‡»å¤„ç† - å¤‡ç”¨æ–¹æ¡ˆ
                this.canvas.addEventListener('click', (event) => {
                    console.log('Canvasç‚¹å‡»äº‹ä»¶è§¦å‘');
                    
                    // åˆ›å»ºæ‹¾å–å°„çº¿
                    const pickRay = this.scene.createPickingRay(
                        this.scene.pointerX, 
                        this.scene.pointerY, 
                        BABYLON.Matrix.Identity(), 
                        this.camera
                    );
                    
                    // æ‰‹åŠ¨æ‰§è¡Œæ‹¾å–
                    const pickInfo = this.scene.pickWithRay(pickRay, (mesh) => {
                        // åªæ‹¾å–ç»„ä»¶ç½‘æ ¼
                        return this.components.some(comp => comp.mesh === mesh);
                    });
                    
                    console.log('æ‰‹åŠ¨æ‹¾å–ç»“æœ:', pickInfo);
                    
                    if (pickInfo && pickInfo.hit) {
                        const component = this.components.find(comp => comp.mesh === pickInfo.pickedMesh);
                        if (component) {
                            console.log('æ‰‹åŠ¨æ‹¾å–æ‰¾åˆ°ç»„ä»¶:', component.type);
                            this.selectComponent(component);
                        }
                    }
                });

                // UIäº‹ä»¶
                this.setupUIEventListeners();

                // å®æ—¶é«˜æ€§èƒ½æ›´æ–° - ç§»é™¤æ‰€æœ‰é™åˆ¶
                this.scene.onBeforeRenderObservable.add(() => {
                    const currentTime = Date.now();
                    
                    // å®æ—¶å…‰çº¿è¿½è¸ªæ›´æ–°ï¼ˆç§»é™¤æ—¶é—´é™åˆ¶ï¼‰
                    if (this.enableRealtimeRayTracing && this.needsRayUpdate) {
                        this.updateRayTracing();
                        this.lastRayUpdateTime = currentTime;
                        this.needsRayUpdate = false;
                    }
                    
                    // é«˜é¢‘ç‡ç³»ç»Ÿä¿¡æ¯æ›´æ–°ï¼ˆæ¯å¸§æ›´æ–°ï¼‰
                    this.updateSystemInfo();
                });

                // é¢å¤–çš„æ¸²æŸ“åå¤„ç†
                this.scene.onAfterRenderObservable.add(() => {
                    // å¼ºåˆ¶æè´¨æ›´æ–°ï¼ˆå¯é€‰ï¼Œæ¶ˆè€—æ€§èƒ½ä½†ç¡®ä¿å®æ—¶æ•ˆæœï¼‰
                    if (this.forceRender && this.components.length > 0) {
                        this.scene.markAllMaterialsAsDirty(BABYLON.Material.AllDirtyFlag);
                    }
                });

                // å®æ—¶Gizmoæ‹–æ‹½ç›‘å¬
                if (this.gizmoManager) {
                    this.scene.onPointerObservable.add((pointerInfo) => {
                        if (pointerInfo.pickInfo?.hit && this.selectedComponent) {
                            // å®æ—¶æ›´æ–°å…‰çº¿è¿½è¸ª
                            this.needsRayUpdate = true;
                        }
                    });
                }

                // çª—å£è°ƒæ•´
                window.addEventListener('resize', () => {
                    if (this.engine) {
                        this.engine.resize();
                    }
                });
                
                console.log('äº‹ä»¶ç›‘å¬å™¨è®¾ç½®å®Œæˆ - å®æ—¶é«˜æ€§èƒ½æ¨¡å¼å·²å¯ç”¨');
            }

            // è·å–é¼ æ ‡åœ¨åœ°é¢ä¸Šçš„æ‹¾å–ç‚¹
            getGroundPickPoint(evt) {
                try {
                    const ray = this.scene.createPickingRay(this.scene.pointerX, this.scene.pointerY, BABYLON.Matrix.Identity(), this.camera);
                    const groundPlane = new BABYLON.Plane(0, 1, 0, 0); // Y=0å¹³é¢
                    const distance = ray.intersectsPlane(groundPlane);
                    
                    if (distance !== null) {
                        return ray.origin.add(ray.direction.scale(distance));
                    }
                    return null;
                } catch (error) {
                    console.error('è·å–æ‹¾å–ç‚¹å¤±è´¥:', error);
                    return null;
                }
            }

            setupUIEventListeners() {
                const componentButtons = document.querySelectorAll('.component-btn');
                componentButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const type = btn.dataset.type;
                        const subtype = btn.dataset.subtype;
                        this.addComponent(type, subtype);
                        
                        componentButtons.forEach(b => b.classList.remove('selected'));
                        btn.classList.add('selected');

                        setTimeout(() => {
                            btn.classList.remove('selected');
                        }, 2000);
                    });
                });
                
                // æ€§èƒ½æ§åˆ¶é¢æ¿äº‹ä»¶ç›‘å¬å™¨
                this.setupPerformanceControls();
                
                console.log('UIäº‹ä»¶ç›‘å¬å™¨è®¾ç½®å®Œæˆ');
            }

            setupPerformanceControls() {
                // å®æ—¶å…‰çº¿è¿½è¸ªæ§åˆ¶
                const realtimeRayTracingCheckbox = document.getElementById('realtimeRayTracing');
                if (realtimeRayTracingCheckbox) {
                    realtimeRayTracingCheckbox.addEventListener('change', (e) => {
                        this.enableRealtimeRayTracing = e.target.checked;
                        this.needsRayUpdate = true;
                        console.log('å®æ—¶å…‰çº¿è¿½è¸ª:', this.enableRealtimeRayTracing ? 'å¯ç”¨' : 'ç¦ç”¨');
                    });
                }

                // å¼ºåˆ¶æ¸²æŸ“æ§åˆ¶
                const forceRenderCheckbox = document.getElementById('forceRender');
                if (forceRenderCheckbox) {
                    forceRenderCheckbox.addEventListener('change', (e) => {
                        this.forceRender = e.target.checked;
                        console.log('å¼ºåˆ¶æ¯å¸§æ¸²æŸ“:', this.forceRender ? 'å¯ç”¨' : 'ç¦ç”¨');
                    });
                }

                // é«˜çº§å…‰çº¿è¿½è¸ªæ§åˆ¶
                const advancedRayTracingCheckbox = document.getElementById('advancedRayTracing');
                if (advancedRayTracingCheckbox) {
                    advancedRayTracingCheckbox.addEventListener('change', (e) => {
                        this.enableAdvancedRayTracing = e.target.checked;
                        this.needsRayUpdate = true;
                        console.log('é«˜çº§å…‰çº¿è¿½è¸ª:', this.enableAdvancedRayTracing ? 'å¯ç”¨' : 'ç¦ç”¨');
                    });
                }

                // å…‰çº¿å¯†åº¦æ§åˆ¶
                const rayDensitySlider = document.getElementById('rayDensity');
                const rayDensityValue = document.getElementById('rayDensityValue');
                if (rayDensitySlider && rayDensityValue) {
                    rayDensitySlider.addEventListener('input', (e) => {
                        this.rayDensity = parseInt(e.target.value);
                        rayDensityValue.textContent = this.rayDensity;
                        this.needsRayUpdate = true;
                        console.log('å…‰çº¿å¯†åº¦è®¾ç½®ä¸º:', this.rayDensity);
                    });
                }

                // æœ€å¤§åå¼¹æ¬¡æ•°æ§åˆ¶
                const maxBouncesSlider = document.getElementById('maxBounces');
                const maxBouncesValue = document.getElementById('maxBouncesValue');
                if (maxBouncesSlider && maxBouncesValue) {
                    maxBouncesSlider.addEventListener('input', (e) => {
                        this.maxBounces = parseInt(e.target.value);
                        maxBouncesValue.textContent = this.maxBounces;
                        this.needsRayUpdate = true;
                        console.log('æœ€å¤§åå¼¹æ¬¡æ•°è®¾ç½®ä¸º:', this.maxBounces);
                    });
                }
                
                // æœ€å¤§GPUè´Ÿè½½æ§åˆ¶
                const maxGpuLoadCheckbox = document.getElementById('maxGpuLoad');
                if (maxGpuLoadCheckbox) {
                    maxGpuLoadCheckbox.addEventListener('change', (e) => {
                        this.maxGpuLoad = e.target.checked;
                        if (this.maxGpuLoad) {
                            this.enableGpuStressMode();
                        } else {
                            this.disableGpuStressMode();
                        }
                        console.log('æœ€å¤§GPUè´Ÿè½½:', this.maxGpuLoad ? 'å¯ç”¨' : 'ç¦ç”¨');
                    });
                }
                
                // æ¸²æŸ“åˆ†è¾¨ç‡æ§åˆ¶
                const renderScaleSlider = document.getElementById('renderScale');
                const renderScaleValue = document.getElementById('renderScaleValue');
                if (renderScaleSlider && renderScaleValue) {
                    renderScaleSlider.addEventListener('input', (e) => {
                        const scale = parseInt(e.target.value);
                        renderScaleValue.textContent = scale + '%';
                        this.updateRenderResolution(scale / 100);
                        console.log('æ¸²æŸ“åˆ†è¾¨ç‡è®¾ç½®ä¸º:', scale + '%');
                    });
                }
                
                // ç›®æ ‡FPSæ§åˆ¶
                const targetFpsSlider = document.getElementById('targetFps');
                const targetFpsValue = document.getElementById('targetFpsValue');
                if (targetFpsSlider && targetFpsValue) {
                    targetFpsSlider.addEventListener('input', (e) => {
                        this.targetFPS = parseInt(e.target.value);
                        targetFpsValue.textContent = this.targetFPS;
                        console.log('ç›®æ ‡FPSè®¾ç½®ä¸º:', this.targetFPS);
                    });
                }
                
                // GPUå‹åŠ›æµ‹è¯•æŒ‰é’®
                const forceGpuStressBtn = document.getElementById('forceGpuStress');
                if (forceGpuStressBtn) {
                    forceGpuStressBtn.addEventListener('click', () => {
                        this.startGpuStressTest();
                    });
                }
                
                // å†…å­˜ä¼˜åŒ–æŒ‰é’®
                const optimizeMemoryBtn = document.getElementById('optimizeMemory');
                if (optimizeMemoryBtn) {
                    optimizeMemoryBtn.addEventListener('click', () => {
                        this.optimizeMemoryUsage();
                    });
                }
                
                console.log('ğŸ”¥ æé™æ€§èƒ½æ§åˆ¶é¢æ¿è®¾ç½®å®Œæˆ');
            }
            
            // å¯ç”¨GPUå‹åŠ›æ¨¡å¼
            enableGpuStressMode() {
                console.log('ğŸ”¥ å¯ç”¨GPUå‹åŠ›æ¨¡å¼...');
                this.createAdditionalGpuLoad();
                // å¢åŠ å…‰çº¿è¿½è¸ªå¤æ‚åº¦
                this.rayDensity = Math.min(this.rayDensity * 2, 10);
                this.maxBounces = Math.min(this.maxBounces * 1.5, 200);
                this.needsRayUpdate = true;
            }
            
            // ç¦ç”¨GPUå‹åŠ›æ¨¡å¼
            disableGpuStressMode() {
                console.log('ğŸ§Š ç¦ç”¨GPUå‹åŠ›æ¨¡å¼...');
                this.removeAdditionalGpuLoad();
            }
            
            // åˆ›å»ºé¢å¤–GPUè´Ÿè½½
            createAdditionalGpuLoad() {
                if (this.gpuStressObjects) return;
                
                this.gpuStressObjects = [];
                for (let i = 0; i < 50; i++) {
                    const torus = BABYLON.MeshBuilder.CreateTorus(`stressTest${i}`, {
                        diameter: 0.5,
                        thickness: 0.1,
                        tessellation: 32
                    }, this.scene);
                    
                    torus.position = new BABYLON.Vector3(
                        (Math.random() - 0.5) * 100,
                        (Math.random() - 0.5) * 100,
                        (Math.random() - 0.5) * 100
                    );
                    
                    torus.isVisible = false; // éšè—ä½†å‚ä¸è®¡ç®—
                    this.gpuStressObjects.push(torus);
                }
                console.log(`âœ… å·²åˆ›å»º ${this.gpuStressObjects.length} ä¸ªGPUå‹åŠ›æµ‹è¯•å¯¹è±¡`);
            }
            
            // ç§»é™¤é¢å¤–GPUè´Ÿè½½
            removeAdditionalGpuLoad() {
                if (this.gpuStressObjects) {
                    this.gpuStressObjects.forEach(obj => obj.dispose());
                    this.gpuStressObjects = null;
                    console.log('ğŸ—‘ï¸ å·²ç§»é™¤GPUå‹åŠ›æµ‹è¯•å¯¹è±¡');
                }
            }
            
            // æ›´æ–°æ¸²æŸ“åˆ†è¾¨ç‡
            updateRenderResolution(scale) {
                const baseWidth = window.innerWidth;
                const baseHeight = window.innerHeight;
                const newWidth = Math.floor(baseWidth * scale);
                const newHeight = Math.floor(baseHeight * scale);
                
                this.engine.setSize(newWidth, newHeight, false);
                console.log(`ğŸ–¥ï¸ æ¸²æŸ“åˆ†è¾¨ç‡æ›´æ–°ä¸º: ${newWidth}x${newHeight} (${Math.round(scale * 100)}%)`);
            }
            
            // å¼€å§‹GPUå‹åŠ›æµ‹è¯•
            startGpuStressTest() {
                console.log('ğŸ”¥ å¼€å§‹GPUå‹åŠ›æµ‹è¯•...');
                
                // ä¸´æ—¶åˆ›å»ºå¤§é‡å¤æ‚å¯¹è±¡
                const stressObjects = [];
                for (let i = 0; i < 100; i++) {
                    const sphere = BABYLON.MeshBuilder.CreateSphere(`gpuStress${i}`, {
                        diameter: 1,
                        segments: 64 // é«˜ç»†åˆ†
                    }, this.scene);
                    
                    sphere.position = new BABYLON.Vector3(
                        (Math.random() - 0.5) * 50,
                        (Math.random() - 0.5) * 50,
                        (Math.random() - 0.5) * 50
                    );
                    
                    // å¤æ‚æè´¨
                    const mat = new BABYLON.StandardMaterial(`stressMat${i}`, this.scene);
                    mat.diffuseColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random());
                    mat.specularPower = 128;
                    sphere.material = mat;
                    
                    sphere.isVisible = false;
                    stressObjects.push(sphere);
                }
                
                // 10ç§’åæ¸…ç†
                setTimeout(() => {
                    stressObjects.forEach(obj => obj.dispose());
                    console.log('ğŸ§¹ GPUå‹åŠ›æµ‹è¯•ç»“æŸï¼Œå·²æ¸…ç†æµ‹è¯•å¯¹è±¡');
                }, 10000);
                
                console.log(`ğŸš€ GPUå‹åŠ›æµ‹è¯•è¿›è¡Œä¸­... (${stressObjects.length} ä¸ªå¯¹è±¡ï¼Œ10ç§’åè‡ªåŠ¨æ¸…ç†)`);
            }
            
            // ä¼˜åŒ–å†…å­˜ä½¿ç”¨
            optimizeMemoryUsage() {
                console.log('ğŸ§¹ å¼€å§‹å†…å­˜ä¼˜åŒ–...');
                
                // æ¸…ç†ç¼“å­˜
                this.scene.cleanCachedTextureBuffer();
                
                // å¼ºåˆ¶åƒåœ¾å›æ”¶
                if (window.gc) {
                    window.gc();
                    console.log('âœ… å·²æ‰§è¡Œå¼ºåˆ¶åƒåœ¾å›æ”¶');
                }
                
                // ä¼˜åŒ–ç½‘æ ¼
                this.scene.meshes.forEach(mesh => {
                    if (mesh.geometry) {
                        mesh.refreshBoundingInfo();
                    }
                });
                
                console.log('âœ… å†…å­˜ä¼˜åŒ–å®Œæˆ');
            }

            addComponent(type, subtype = null) {
                try {
                    let mesh;
                    const position = new BABYLON.Vector3(
                        (Math.random() - 0.5) * 10,
                        1,
                        (Math.random() - 0.5) * 8
                    );

                    const properties = this.getDefaultProperties(type, subtype);

                    switch (type) {
                        case 'laser':
                            mesh = this.createLaser(position, properties);
                            break;
                        case 'lens':
                            mesh = this.createLens(subtype, position, properties);
                            break;
                        case 'mirror':
                            mesh = this.createMirror(subtype, position, properties);
                            break;
                        case 'prism':
                            mesh = this.createPrism(position, properties);
                            break;
                        case 'grating':
                            mesh = this.createGrating(position, properties);
                            break;
                        case 'screen':
                            mesh = this.createScreen(position, properties);
                            break;
                    }

                    if (mesh) {
                        const component = {
                            mesh: mesh,
                            type: type,
                            subtype: subtype,
                            properties: properties,
                            id: 'comp_' + Date.now()
                        };

                        mesh.metadata = {
                            type: this.getOpticalType(type, subtype),
                            ior: properties.ior || 1.0,
                            component: component
                        };

                        this.components.push(component);
                        
                        console.log(`ç»„ä»¶åˆ›å»ºæˆåŠŸ: ${type}, æ€»æ•°: ${this.components.length}`);
                        console.log('æ–°åˆ›å»ºçš„ç½‘æ ¼:', mesh.name, 'å¯æ‹¾å–:', mesh.isPickable);
                        console.log('ç»„ä»¶åˆ—è¡¨:', this.components.map(c => `${c.type}(${c.mesh.name})`));
                        
                        this.selectComponent(component);
                        this.needsRayUpdate = true;
                    }
                } catch (error) {
                    console.error('ç»„ä»¶åˆ›å»ºå¤±è´¥:', error);
                }
            }

            getOpticalType(type, subtype) {
                switch (type) {
                    case 'laser':
                        return 'source';
                    case 'lens':
                    case 'prism':
                        return 'refractive';
                    case 'mirror':
                        return 'reflective';
                    case 'grating':
                        return 'diffractive';
                    case 'screen':
                        return 'absorptive';
                    default:
                        return 'unknown';
                }
            }

            createLaser(position, properties) {
                const mesh = BABYLON.MeshBuilder.CreateCylinder("laser", {
                    height: 1,
                    diameter: 0.5
                }, this.scene);
                
                mesh.position = position;
                mesh.rotation.z = Math.PI / 2;
                
                // ç¡®ä¿meshå¯ä»¥è¢«æ‹¾å–
                mesh.isPickable = true;
                
                const material = new BABYLON.StandardMaterial("laserMat", this.scene);
                material.diffuseColor = this.hexToColor3(properties.color || "#ff0000");
                material.emissiveColor = material.diffuseColor.scale(0.3);
                mesh.material = material;
                
                return mesh;
            }

            // åˆ›å»ºé€é•œå½¢çŠ¶ï¼ˆæ ¹æ®é€é•œåˆ¶é€ è€…å…¬å¼å’Œå…‰å­¦åŸç†ï¼‰
            createLens(subtype, position, properties) {
                let mesh;
                const focalLength = properties.focalLength || 50;
                const diameter = properties.diameter || 25;
                const ior = properties.ior || 1.5;
                const userThickness = properties.thickness || null;
                const isConvex = focalLength > 0;
                
                // è®¡ç®—é€é•œå‚æ•°
                const R = 2 * Math.abs(focalLength) * (ior - 1);
                const sagitta = Math.pow(diameter/2, 2) / (2 * R);
                const minThickness = Math.max(0.5, diameter * 0.02);
                const maxThickness = diameter * 0.6;
                
                let centerThickness;
                if (userThickness !== null && userThickness > 0) {
                    centerThickness = Math.max(minThickness, Math.min(maxThickness, userThickness));
                } else {
                    if (focalLength > 0) {
                        centerThickness = Math.max(minThickness, Math.min(maxThickness, sagitta * 2 + minThickness));
                    } else {
                        centerThickness = Math.max(minThickness, maxThickness - sagitta * 1.5);
                    }
                }
                
                if (isConvex) {
                    mesh = this.createConvexLens(diameter, centerThickness, R);
                } else {
                    mesh = this.createConcaveLens(diameter, centerThickness, R);
                }
                
                mesh.position = position;
                mesh.rotation.z = Math.PI / 2;
                
                // ç¡®ä¿meshå¯ä»¥è¢«æ‹¾å–
                mesh.isPickable = true;
                
                const material = new BABYLON.StandardMaterial("lensMat", this.scene);
                material.diffuseColor = this.hexToColor3(properties.color || "#80c0ff");
                material.alpha = properties.transparency || 0.6;
                material.specularColor = new BABYLON.Color3(1, 1, 1);
                material.specularPower = 64;
                mesh.material = material;
                
                return mesh;
            }
            
            // åˆ›å»ºå‡¸é€é•œå‡ ä½•ä½“
            createConvexLens(diameter, centerThickness, radiusOfCurvature) {
                // ä½¿ç”¨çƒä½“åˆ›å»ºå‡¸é€é•œï¼Œç„¶åæ‰å¹³åŒ–
                const lens = BABYLON.MeshBuilder.CreateSphere("convexLens", {
                    diameter: diameter / 10,
                    segments: 32
                }, this.scene);
                
                // è®¡ç®—åšåº¦æ¯”ä¾‹
                const thicknessRatio = Math.max(0.1, Math.min(0.8, centerThickness / diameter));
                
                // æ‰å¹³åŒ–å½¢æˆé€é•œå½¢çŠ¶
                lens.scaling.x = thicknessRatio;
                
                // ç¡®ä¿meshå¯ä»¥è¢«æ‹¾å–
                lens.isPickable = true;
                
                return lens;
            }
            
            // åˆ›å»ºå‡¹é€é•œå‡ ä½•ä½“
            createConcaveLens(diameter, centerThickness, radiusOfCurvature) {
                // ä½¿ç”¨åœ†æŸ±ä½“åˆ›å»ºå‡¹é€é•œåŸºç¡€
                const edgeThickness = Math.max(centerThickness * 1.5, diameter * 0.05);
                const lens = BABYLON.MeshBuilder.CreateCylinder("concaveLens", {
                    diameter: diameter / 10,
                    height: edgeThickness / 10,
                    tessellation: 32
                }, this.scene);
                
                // åˆ›å»ºä¸­å¿ƒå‡¹é™·æ•ˆæœ
                const positions = lens.getVerticesData(BABYLON.VertexBuffer.PositionKind);
                if (positions) {
                    for (let i = 0; i < positions.length; i += 3) {
                        const x = positions[i];
                        const y = positions[i + 1];
                        const z = positions[i + 2];
                        
                        // è®¡ç®—è·ç¦»ä¸­å¿ƒçš„å¾„å‘è·ç¦»
                        const radialDistance = Math.sqrt(y * y + z * z);
                        const maxRadius = diameter / 20;
                        
                        if (radialDistance < maxRadius) {
                            // åœ¨ä¸­å¿ƒåŒºåŸŸåˆ›å»ºå‡¹é™·
                            const normalizedRadius = radialDistance / maxRadius;
                            const depression = (1 - normalizedRadius * normalizedRadius) * 0.5;
                            positions[i] = x * (1 - depression);
                        }
                    }
                    lens.setVerticesData(BABYLON.VertexBuffer.PositionKind, positions);
                }
                
                // ç¡®ä¿meshå¯ä»¥è¢«æ‹¾å–
                lens.isPickable = true;
                
                return lens;
            }

            createMirror(subtype, position, properties) {
                let mesh;
                
                if (subtype === 'plane') {
                    mesh = BABYLON.MeshBuilder.CreateBox("mirror", {
                        width: properties.width / 10, 
                        height: properties.height / 10, 
                        depth: properties.thickness / 100
                    }, this.scene);
                } else {
                    // å‡¹é¢é•œä½¿ç”¨éƒ¨åˆ†çƒä½“
                    mesh = BABYLON.MeshBuilder.CreateSphere("concaveMirror", {
                        diameter: properties.diameter / 10,
                        segments: 32,
                        arc: 0.5
                    }, this.scene);
                    mesh.scaling = new BABYLON.Vector3(0.2, 1, 1);
                }
                
                mesh.position = position;
                if (subtype === 'plane') {
                    mesh.rotation.y = -Math.PI / 4;
                }
                
                // ç¡®ä¿meshå¯ä»¥è¢«æ‹¾å–
                mesh.isPickable = true;
                
                const material = new BABYLON.StandardMaterial("mirrorMat", this.scene);
                material.diffuseColor = this.hexToColor3(properties.color || "#c0c0c0");
                material.specularColor = new BABYLON.Color3(0.9, 0.9, 0.9);
                material.specularPower = 128;
                material.reflectionTexture = new BABYLON.MirrorTexture("mirrorTexture", 512, this.scene);
                material.reflectionTexture.mirrorPlane = new BABYLON.Plane(0, 0, -1, 0);
                mesh.material = material;
                
                return mesh;
            }

            createPrism(position, properties) {
                const mesh = BABYLON.MeshBuilder.CreateCylinder("prism", {
                    diameter: properties.size / 10,
                    height: properties.height / 10,
                    tessellation: 3
                }, this.scene);
                
                mesh.position = position;
                mesh.rotation.x = Math.PI / 2;
                mesh.rotation.y = (properties.rotation || 0) * Math.PI / 180;
                
                // ç¡®ä¿meshå¯ä»¥è¢«æ‹¾å–
                mesh.isPickable = true;
                
                const material = new BABYLON.StandardMaterial("prismMat", this.scene);
                material.diffuseColor = this.hexToColor3(properties.color || "#f0f0f5");
                material.alpha = properties.transparency || 0.7;
                material.specularColor = new BABYLON.Color3(1, 1, 1);
                mesh.material = material;
                
                return mesh;
            }

            createGrating(position, properties) {
                // åˆ›å»ºç®€åŒ–çš„å…‰æ …
                const mesh = BABYLON.MeshBuilder.CreatePlane("grating", {
                    size: properties.size / 10
                }, this.scene);
                
                mesh.position = position;
                
                // ç¡®ä¿meshå¯ä»¥è¢«æ‹¾å–
                mesh.isPickable = true;
                
                const material = new BABYLON.StandardMaterial("gratingMat", this.scene);
                material.diffuseColor = this.hexToColor3(properties.color || "#808080");
                material.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                
                // åˆ›å»ºå…‰æ …çº¹ç†
                const texture = new BABYLON.DynamicTexture("gratingTexture", {width: 512, height: 512}, this.scene);
                const ctx = texture.getContext();
                
                // ç»˜åˆ¶å…‰æ …çº¿æ¡
                ctx.fillStyle = "#808080";
                ctx.fillRect(0, 0, 512, 512);
                
                const lineCount = Math.min(50, properties.linesPerMM / 10);
                const lineWidth = 512 / lineCount;
                
                ctx.fillStyle = "#404040";
                for (let i = 0; i < lineCount; i += 2) {
                    ctx.fillRect(i * lineWidth, 0, lineWidth / 2, 512);
                }
                
                texture.update();
                material.diffuseTexture = texture;
                mesh.material = material;
                
                return mesh;
            }

            createScreen(position, properties) {
                const mesh = BABYLON.MeshBuilder.CreatePlane("screen", {
                    width: properties.width / 10,
                    height: properties.height / 10
                }, this.scene);
                
                mesh.position = position;
                
                // ç¡®ä¿meshå¯ä»¥è¢«æ‹¾å–
                mesh.isPickable = true;
                
                const material = new BABYLON.StandardMaterial("screenMat", this.scene);
                material.diffuseColor = this.hexToColor3(properties.color || "#ffffff");
                material.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                mesh.material = material;
                
                return mesh;
            }

            getDefaultProperties(type, subtype) {
                const defaults = {
                    laser: {
                        wavelength: 632.8,
                        power: 5,
                        beamDiameter: 1,
                        color: "#ff0000",
                        divergence: 0.1
                    },
                    lens: {
                        ior: 1.5,
                        focalLength: 50,
                        diameter: 25,
                        thickness: 5,
                        color: "#80c0ff",
                        transparency: 0.6
                    },
                    mirror: {
                        reflectivity: 0.95,
                        curvature: subtype === 'plane' ? 0 : 100,
                        width: 25,
                        height: 25,
                        thickness: 3,
                        diameter: 25,
                        color: "#c0c0c0"
                    },
                    prism: {
                        ior: 1.6,
                        apexAngle: 60,
                        size: 15,
                        height: 15,
                        rotation: 0,
                        color: "#f0f0f5",
                        transparency: 0.7
                    },
                    grating: {
                        linesPerMM: 500,
                        efficiency: 0.8,
                        size: 20,
                        blazeAngle: 0,
                        color: "#808080"
                    },
                    screen: {
                        width: 30,
                        height: 30,
                        color: "#ffffff"
                    }
                };

                return defaults[type] || {};
            }

            hexToColor3(hex) {
                const r = parseInt(hex.slice(1, 3), 16) / 255;
                const g = parseInt(hex.slice(3, 5), 16) / 255;
                const b = parseInt(hex.slice(5, 7), 16) / 255;
                return new BABYLON.Color3(r, g, b);
            }

            color3ToHex(color3) {
                const r = Math.round(color3.r * 255).toString(16).padStart(2, '0');
                const g = Math.round(color3.g * 255).toString(16).padStart(2, '0');
                const b = Math.round(color3.b * 255).toString(16).padStart(2, '0');
                return `#${r}${g}${b}`;
            }

            selectComponent(component) {
                console.log('å¼€å§‹é€‰æ‹©ç»„ä»¶:', component.type);
                this.clearSelection();
                
                this.selectedComponent = component;
                
                if (this.gizmoManager) {
                    console.log('GizmoManagerå¯ç”¨ï¼Œè®¾ç½®Gizmoæ¨¡å¼:', this.transformMode);
                    
                    try {
                        // æ ¹æ®å½“å‰å˜æ¢æ¨¡å¼è®¾ç½®Gizmo
                        this.setTransformMode(this.transformMode);
                        
                        console.log('é™„åŠ Gizmoåˆ°ç»„ä»¶');
                        this.gizmoManager.attachToMesh(component.mesh);
                        
                        // éªŒè¯Gizmoæ˜¯å¦æ­£ç¡®é™„åŠ 
                        if (this.gizmoManager.attachedMesh === component.mesh) {
                            console.log('GizmoæˆåŠŸé™„åŠ åˆ°ç»„ä»¶');
                        } else {
                            console.warn('Gizmoé™„åŠ å¯èƒ½å¤±è´¥');
                        }
                    } catch (error) {
                        console.error('Gizmoæ“ä½œå¤±è´¥:', error);
                    }
                } else {
                    console.warn('GizmoManager ä¸å¯ç”¨');
                }
                
                this.updatePropertiesPanel();
                
                // æ·»åŠ é«˜äº®æ•ˆæœ
                if (component.mesh.material) {
                    component.originalEmissive = component.mesh.material.emissiveColor.clone();
                    component.mesh.material.emissiveColor = new BABYLON.Color3(0, 0.2, 0.4);
                }
                
                console.log(`é€‰ä¸­ç»„ä»¶: ${component.type} (${this.transformMode}æ¨¡å¼)`);
            }

            clearSelection() {
                if (this.selectedComponent) {
                    // æ¢å¤åŸå§‹å‘å…‰é¢œè‰²
                    if (this.selectedComponent.mesh.material && this.selectedComponent.originalEmissive) {
                        this.selectedComponent.mesh.material.emissiveColor = this.selectedComponent.originalEmissive;
                    }
                    
                    if (this.gizmoManager) {
                        this.gizmoManager.attachToMesh(null);
                    }
                    
                    this.selectedComponent = null;
                    
                    // æ¸…ç†å›è°ƒå‡½æ•°
                    if (window.sliderCallbacks) {
                        window.sliderCallbacks = {};
                    }
                    if (window.colorCallbacks) {
                        window.colorCallbacks = {};
                    }
                    
                    const panel = document.getElementById('propertyControls');
                    if (panel) {
                        panel.innerHTML = '<p>é€‰æ‹©ä¸€ä¸ªç»„ä»¶æ¥ç¼–è¾‘å±æ€§</p>';
                    }
                }
            }

            updatePropertiesPanel() {
                if (!this.selectedComponent) return;
                
                const panel = document.getElementById('propertyControls');
                const component = this.selectedComponent;
                const mesh = component.mesh;
                const pos = mesh.position;
                const rot = mesh.rotation;
                
                let html = `<div style="margin-bottom: 10px;"><strong>ID:</strong> ${component.id}</div>`;
                
                // ç‰¹æ®Šå¤„ç†é€é•œç±»å‹æ˜¾ç¤º
                let typeDisplay = component.type;
                if (component.type === 'lens') {
                    const focalLength = component.properties.focalLength || 50;
                    typeDisplay = focalLength > 0 ? 'å‡¸é€é•œ' : 'å‡¹é€é•œ';
                } else if (component.subtype) {
                    typeDisplay += ' - ' + component.subtype;
                }
                
                html += `<div style="margin-bottom: 10px;"><strong>ç±»å‹:</strong> ${typeDisplay}</div>`;
                html += `<div style="margin-bottom: 15px; padding: 8px; background: rgba(0, 150, 255, 0.2); border-radius: 4px; border: 1px solid #0099ff;">
                    <strong>å˜æ¢æ¨¡å¼:</strong> ${this.transformMode === 'translate' ? 'ç§»åŠ¨ (æŒ‰Té”®)' : 'æ—‹è½¬ (æŒ‰Ré”®)'}
                </div>`;
                
                // ä½ç½®æ§åˆ¶
                html += this.createSlider("ä½ç½® X", pos.x, -10, 10, 0.1, (val) => {
                    mesh.position.x = val;
                    this.needsRayUpdate = true;
                });
                html += this.createSlider("ä½ç½® Y", pos.y, 0, 10, 0.1, (val) => {
                    mesh.position.y = val;
                    this.needsRayUpdate = true;
                });
                html += this.createSlider("ä½ç½® Z", pos.z, -10, 10, 0.1, (val) => {
                    mesh.position.z = val;
                    this.needsRayUpdate = true;
                });
                
                // æ—‹è½¬æ§åˆ¶
                html += this.createSlider("æ—‹è½¬ X", rot.x * 180 / Math.PI, -180, 180, 1, (val) => {
                    mesh.rotation.x = val * Math.PI / 180;
                    this.needsRayUpdate = true;
                });
                html += this.createSlider("æ—‹è½¬ Y", rot.y * 180 / Math.PI, -180, 180, 1, (val) => {
                    mesh.rotation.y = val * Math.PI / 180;
                    this.needsRayUpdate = true;
                });
                html += this.createSlider("æ—‹è½¬ Z", rot.z * 180 / Math.PI, -180, 180, 1, (val) => {
                    mesh.rotation.z = val * Math.PI / 180;
                    this.needsRayUpdate = true;
                });
                
                // ç»„ä»¶ç‰¹å®šå±æ€§
                html = this.addComponentSpecificProperties(html, component);
                
                // åˆ é™¤æŒ‰é’®
                html += `<div class="property-group">
                    <button onclick="opticalSystemGame.removeSelectedComponent()">åˆ é™¤ç»„ä»¶</button>
                </div>`;
                
                panel.innerHTML = html;
                
                // æ·»åŠ æ»‘å—å’Œé¢œè‰²é€‰æ‹©å™¨äº‹ä»¶
                this.setupSliderEvents();
                this.setupColorEvents();
            }

            addComponentSpecificProperties(html, component) {
                const props = component.properties;
                
                switch (component.type) {
                    case 'laser':
                        html += this.createSlider("æ³¢é•¿ (nm)", props.wavelength, 400, 700, 1, (val) => {
                            props.wavelength = val;
                            this.updateLaserColor(component, val);
                            this.needsRayUpdate = true;
                        });
                        html += this.createSlider("åŠŸç‡ (mW)", props.power, 1, 100, 1, (val) => {
                            props.power = val;
                        });
                        html += this.createSlider("å…‰æŸç›´å¾„", props.beamDiameter, 0.5, 5, 0.1, (val) => {
                            props.beamDiameter = val;
                            this.needsRayUpdate = true;
                        });
                        html += this.createColorPicker("é¢œè‰²", props.color, (val) => {
                            props.color = val;
                            this.updateMeshColor(component.mesh, val);
                        });
                        break;
                        
                    case 'lens':
                        html += this.createSlider("æŠ˜å°„ç‡", props.ior, 1.0, 2.5, 0.01, (val) => {
                            props.ior = val;
                            component.mesh.metadata.ior = val;
                            this.updateLensShape(component);
                            this.needsRayUpdate = true;
                        });
                        html += this.createSlider("ç„¦è· (mm)", props.focalLength, -200, 200, 1, (val) => {
                            props.focalLength = val;
                            this.updateLensShape(component);
                            this.needsRayUpdate = true;
                        });
                        html += this.createSlider("ç›´å¾„ (mm)", props.diameter, 10, 50, 1, (val) => {
                            props.diameter = val;
                            this.updateLensShape(component);
                            this.needsRayUpdate = true;
                        });
                        html += this.createSlider("ä¸­å¿ƒåšåº¦ (mm)", props.thickness, 0.5, 15, 0.1, (val) => {
                            props.thickness = val;
                            this.updateLensShape(component);
                            this.needsRayUpdate = true;
                        });
                        html += this.createSlider("é€æ˜åº¦", props.transparency, 0.1, 1.0, 0.05, (val) => {
                            props.transparency = val;
                            if (component.mesh.material) {
                                component.mesh.material.alpha = val;
                            }
                        });
                        html += this.createColorPicker("é¢œè‰²", props.color, (val) => {
                            props.color = val;
                            this.updateMeshColor(component.mesh, val);
                        });
                        
                        // æ˜¾ç¤ºè®¡ç®—å‡ºçš„é€é•œå‚æ•°
                        const R = 2 * Math.abs(props.focalLength) * (props.ior - 1);
                        const sagitta = Math.pow(props.diameter/2, 2) / (2 * R);
                        html += `<div style="margin-top: 10px; padding: 5px; background: rgba(0, 100, 200, 0.2); border-radius: 3px; font-size: 11px;">
                            <strong>è®¡ç®—å‚æ•°:</strong><br>
                            æ›²ç‡åŠå¾„: ${R.toFixed(1)} mm<br>
                            çŸ¢é«˜: ${sagitta.toFixed(2)} mm<br>
                            é€é•œç±»å‹: ${props.focalLength > 0 ? 'å‡¸é€é•œ' : 'å‡¹é€é•œ'}
                        </div>`;
                        break;
                        
                    case 'mirror':
                        html += this.createSlider("åå°„ç‡", props.reflectivity, 0.5, 1.0, 0.01, (val) => {
                            props.reflectivity = val;
                            this.needsRayUpdate = true;
                        });
                        if (component.subtype === 'plane') {
                            html += this.createSlider("å®½åº¦ (mm)", props.width, 10, 50, 1, (val) => {
                                props.width = val;
                                this.updateMirrorSize(component, val, props.height);
                                this.needsRayUpdate = true;
                            });
                            html += this.createSlider("é«˜åº¦ (mm)", props.height, 10, 50, 1, (val) => {                                props.height = val;
                                this.updateMirrorSize(component, props.width, val);
                                this.needsRayUpdate = true;
                            });
                        } else {
                            html += this.createSlider("ç›´å¾„ (mm)", props.diameter, 10, 50, 1, (val) => {
                                props.diameter = val;
                                this.updateMirrorSize(component, val, val);
                                this.needsRayUpdate = true;
                            });
                        }
                        html += this.createColorPicker("é¢œè‰²", props.color, (val) => {
                            props.color = val;
                            this.updateMeshColor(component.mesh, val);
                        });
                        break;
                        
                    case 'prism':
                        html += this.createSlider("æŠ˜å°„ç‡", props.ior, 1.0, 2.5, 0.01, (val) => {
                            props.ior = val;
                            component.mesh.metadata.ior = val;
                            this.needsRayUpdate = true;
                        });
                        html += this.createSlider("é¡¶è§’ (åº¦)", props.apexAngle, 30, 90, 1, (val) => {
                            props.apexAngle = val;
                            this.needsRayUpdate = true;
                        });
                        html += this.createSlider("å°ºå¯¸ (mm)", props.size, 10, 30, 1, (val) => {
                            props.size = val;
                            this.updatePrismSize(component, val);
                            this.needsRayUpdate = true;
                        });
                        html += this.createSlider("é€æ˜åº¦", props.transparency, 0.3, 1.0, 0.05, (val) => {
                            props.transparency = val;
                            if (component.mesh.material) {
                                component.mesh.material.alpha = val;
                            }
                        });
                        html += this.createColorPicker("é¢œè‰²", props.color, (val) => {
                            props.color = val;
                            this.updateMeshColor(component.mesh, val);
                        });
                        break;
                        
                    case 'grating':
                        html += this.createSlider("çº¿å¯†åº¦ (çº¿/mm)", props.linesPerMM, 100, 2000, 10, (val) => {
                            props.linesPerMM = val;
                            this.updateGratingTexture(component);
                            this.needsRayUpdate = true;
                        });
                        html += this.createSlider("æ•ˆç‡", props.efficiency, 0.1, 1.0, 0.05, (val) => {
                            props.efficiency = val;
                            this.needsRayUpdate = true;
                        });
                        html += this.createSlider("å°ºå¯¸ (mm)", props.size, 10, 40, 1, (val) => {
                            props.size = val;
                            component.mesh.scaling = new BABYLON.Vector3(val/20, val/20, 1);
                            this.needsRayUpdate = true;
                        });
                        html += this.createColorPicker("é¢œè‰²", props.color, (val) => {
                            props.color = val;
                            this.updateMeshColor(component.mesh, val);
                        });
                        break;
                        
                    case 'screen':
                        html += this.createSlider("å®½åº¦ (mm)", props.width, 10, 60, 1, (val) => {
                            props.width = val;
                            this.updateScreenSize(component, val, props.height);
                        });
                        html += this.createSlider("é«˜åº¦ (mm)", props.height, 10, 60, 1, (val) => {
                            props.height = val;
                            this.updateScreenSize(component, props.width, val);
                        });
                        html += this.createColorPicker("é¢œè‰²", props.color, (val) => {
                            props.color = val;
                            this.updateMeshColor(component.mesh, val);
                        });
                        break;
                }
                
                return html;
            }

            createSlider(label, value, min, max, step, callback) {
                const id = 'slider_' + Math.random().toString(36).substr(2, 9);
                
                // å­˜å‚¨å›è°ƒå‡½æ•°
                if (!window.sliderCallbacks) window.sliderCallbacks = {};
                window.sliderCallbacks[id] = callback;
                
                return `
                    <div class="prop-slider">
                        <label>${label}</label>
                        <input type="range" id="${id}" min="${min}" max="${max}" step="${step}" value="${value}">
                        <input type="number" id="${id}_text" value="${parseFloat(value).toFixed(2)}" min="${min}" max="${max}" step="${step}">
                    </div>
                `;
            }

            createColorPicker(label, value, callback) {
                const id = 'color_' + Math.random().toString(36).substr(2, 9);
                
                // å­˜å‚¨å›è°ƒå‡½æ•°
                if (!window.colorCallbacks) window.colorCallbacks = {};
                window.colorCallbacks[id] = callback;
                
                return `
                    <div class="prop-color">
                        <label>${label}</label>
                        <input type="color" id="${id}" value="${value}">
                    </div>
                `;
            }

            setupSliderEvents() {
                document.querySelectorAll('#propertyControls input[type="range"]').forEach(slider => {
                    const textInput = document.getElementById(slider.id + '_text');
                    
                    const updateValue = (value) => {
                        value = parseFloat(value);
                        if (!isNaN(value)) {
                            slider.value = value;
                            textInput.value = value.toFixed(2);
                            
                            const callback = window.sliderCallbacks[slider.id];
                            if (callback) callback(value);
                        }
                    };
                    
                    slider.oninput = () => updateValue(slider.value);
                    textInput.onchange = () => updateValue(textInput.value);
                });
            }

            setupColorEvents() {
                document.querySelectorAll('#propertyControls input[type="color"]').forEach(colorPicker => {
                    colorPicker.onchange = () => {
                        const callback = window.colorCallbacks[colorPicker.id];
                        if (callback) callback(colorPicker.value);
                    };
                });
            }

            updateLaserColor(component, wavelength) {
                // æ ¹æ®æ³¢é•¿è®¡ç®—é¢œè‰²
                let r, g, b;
                if (wavelength >= 380 && wavelength < 440) {
                    r = -(wavelength - 440) / (440 - 380);
                    g = 0.0;
                    b = 1.0;
                } else if (wavelength >= 440 && wavelength < 490) {
                    r = 0.0;
                    g = (wavelength - 440) / (490 - 440);
                    b = 1.0;
                } else if (wavelength >= 490 && wavelength < 510) {
                    r = 0.0;
                    g = 1.0;
                    b = -(wavelength - 510) / (510 - 490);
                } else if (wavelength >= 510 && wavelength < 580) {
                    r = (wavelength - 510) / (580 - 510);
                    g = 1.0;
                    b = 0.0;
                } else if (wavelength >= 580 && wavelength < 645) {
                    r = 1.0;
                    g = -(wavelength - 645) / (645 - 580);
                    b = 0.0;
                } else if (wavelength >= 645 && wavelength <= 750) {
                    r = 1.0;
                    g = 0.0;
                    b = 0.0;
                } else {
                    r = 1.0;
                    g = 0.0;
                    b = 0.0;
                }
                
                const color = new BABYLON.Color3(r, g, b);
                component.mesh.material.diffuseColor = color;
                component.mesh.material.emissiveColor = color.scale(0.3);
                component.properties.color = this.color3ToHex(color);
            }

            updateMeshColor(mesh, hex) {
                if (mesh.material) {
                    mesh.material.diffuseColor = this.hexToColor3(hex);
                }
            }

            updateLensSize(component, diameter) {
                // ç›´å¾„æ”¹å˜æ—¶é‡æ–°åˆ›å»ºé€é•œä»¥ä¿æŒæ­£ç¡®çš„æ¯”ä¾‹
                this.updateLensShape(component);
            }
            
            updateLensShape(component) {
                const focalLength = component.properties.focalLength || 50;
                const diameter = component.properties.diameter || 25;
                const ior = component.properties.ior || 1.5;
                const userThickness = component.properties.thickness || null;
                
                // ä¿å­˜å½“å‰çŠ¶æ€
                const oldPosition = component.mesh.position.clone();
                const oldRotation = component.mesh.rotation.clone();
                const oldMaterial = component.mesh.material;
                
                // åˆ é™¤æ—§ç½‘æ ¼
                component.mesh.dispose();
                
                // è®¡ç®—é€é•œå‚æ•°ï¼ˆä¼˜å…ˆä½¿ç”¨ç”¨æˆ·è®¾ç½®çš„åšåº¦ï¼‰
                const isConvex = focalLength > 0;
                const R = 2 * Math.abs(focalLength) * (ior - 1);
                const sagitta = Math.pow(diameter/2, 2) / (2 * R);
                const minThickness = Math.max(0.5, diameter * 0.02);
                const maxThickness = diameter * 0.6;
                
                let centerThickness;
                if (userThickness !== null && userThickness > 0) {
                    centerThickness = Math.max(minThickness, Math.min(maxThickness, userThickness));
                } else {
                    if (focalLength > 0) {
                        centerThickness = Math.max(minThickness, Math.min(maxThickness, sagitta * 2 + minThickness));
                    } else {
                        centerThickness = Math.max(minThickness, maxThickness - sagitta * 1.5);
                    }
                }
                
                // åˆ›å»ºæ–°çš„é€é•œç½‘æ ¼
                let newMesh;
                if (isConvex) {
                    newMesh = this.createConvexLens(diameter, centerThickness, R);
                } else {
                    newMesh = this.createConcaveLens(diameter, centerThickness, R);
                }
                
                // æ¢å¤çŠ¶æ€
                newMesh.position = oldPosition;
                newMesh.rotation = oldRotation;
                newMesh.material = oldMaterial;
                
                // ç¡®ä¿æ–°meshå¯ä»¥è¢«æ‹¾å–
                newMesh.isPickable = true;
                
                // æ›´æ–°ç»„ä»¶å¼•ç”¨
                component.mesh = newMesh;
                
                // æ›´æ–°metadata
                component.mesh.metadata = {
                    type: 'refractive',
                    ior: ior,
                    component: component
                };
                
                // å¦‚æœå½“å‰ç»„ä»¶è¢«é€‰ä¸­ï¼Œéœ€è¦é‡æ–°é€‰æ‹©ä»¥æ›´æ–°Gizmo
                if (this.selectedComponent === component) {
                    // ä¸´æ—¶æ¸…é™¤é€‰æ‹©
                    this.selectedComponent = null;
                    // é‡æ–°é€‰æ‹©ä»¥æ›´æ–°Gizmoé™„ç€
                    setTimeout(() => {
                        this.selectComponent(component);
                    }, 50);
                }
                
                console.log(`é€é•œå½¢çŠ¶å·²æ›´æ–°: ç„¦è·=${focalLength}mm, ç›´å¾„=${diameter}mm, åšåº¦=${centerThickness.toFixed(1)}mm, ç±»å‹=${isConvex ? 'å‡¸é€é•œ' : 'å‡¹é€é•œ'}`);
            }

            updateMirrorSize(component, width, height) {
                if (component.subtype === 'plane') {
                    component.mesh.scaling.x = width / 25;
                    component.mesh.scaling.y = height / 25;
                } else {
                    // å‡¹é¢é•œ
                    const scale = width / 25;
                    component.mesh.scaling.y = scale;
                    component.mesh.scaling.z = scale;
                }
            }

            updatePrismSize(component, size) {
                const scale = size / 15; // åŸºå‡†å°ºå¯¸
                component.mesh.scaling = new BABYLON.Vector3(scale, scale, scale);
            }

            updateScreenSize(component, width, height) {
                component.mesh.scaling.x = width / 30;
                component.mesh.scaling.y = height / 30;
            }

            updateGratingTexture(component) {
                if (component.mesh.material && component.mesh.material.diffuseTexture) {
                    const texture = component.mesh.material.diffuseTexture;
                    const ctx = texture.getContext();
                    
                    // é‡æ–°ç»˜åˆ¶å…‰æ …çº¹ç†
                    ctx.fillStyle = "#808080";
                    ctx.fillRect(0, 0, 512, 512);
                    
                    const lineCount = Math.min(50, component.properties.linesPerMM / 10);
                    const lineWidth = 512 / lineCount;
                    
                    ctx.fillStyle = "#404040";
                    for (let i = 0; i < lineCount; i += 2) {
                        ctx.fillRect(i * lineWidth, 0, lineWidth / 2, 512);
                    }
                    
                    texture.update();
                }
            }

            removeSelectedComponent() {
                if (this.selectedComponent) {
                    const index = this.components.indexOf(this.selectedComponent);
                    if (index > -1) {
                        this.selectedComponent.mesh.dispose();
                        this.components.splice(index, 1);
                        this.clearSelection();
                        this.needsRayUpdate = true;
                    }
                }
            }

            updateRayTracing() {
                // é«˜æ€§èƒ½å…‰çº¿è¿½è¸ª - ç§»é™¤æ‰€æœ‰é™åˆ¶
                try {
                    // æ¸…é™¤æ—§å…‰çº¿
                    this.rayLines.forEach(line => {
                        if (line && line.dispose) {
                            line.dispose();
                        }
                    });
                    this.rayLines = [];
                    
                    // æ‰¾åˆ°æ‰€æœ‰å…‰æº
                    const lightSources = this.components.filter(comp => comp.type === 'laser');
                    
                    // å¹¶è¡Œå¤„ç†å¤šä¸ªå…‰æºï¼ˆå¦‚æœæ”¯æŒï¼‰
                    lightSources.forEach(source => {
                        // åŸºç¡€å…‰çº¿
                        this.traceRaysFromSource(source);
                        
                        // å¦‚æœå¯ç”¨é«˜çº§å…‰çº¿è¿½è¸ªï¼Œæ·»åŠ å¤šæ¡å…‰çº¿ä»¥æ¨¡æ‹Ÿå…‰æŸ
                        if (this.enableAdvancedRayTracing && this.rayDensity > 1) {
                            for (let i = 1; i < this.rayDensity; i++) {
                                const offset = (i / this.rayDensity - 0.5) * 0.1;
                                this.traceRaysFromSource(source, offset);
                            }
                        }
                    });
                    
                    console.log(`å®æ—¶å…‰çº¿è¿½è¸ªå®Œæˆ: ${this.rayLines.length} æ¡å…‰çº¿, ${lightSources.length} ä¸ªå…‰æº`);
                } catch (error) {
                    console.error('å…‰çº¿è¿½è¸ªé”™è¯¯:', error);
                }
            }

            traceRaysFromSource(source, offsetY = 0) {
                try {
                    const laserDirection = source.mesh.getDirection(new BABYLON.Vector3(1, 0, 0));
                    
                    // è®¡ç®—èµ·å§‹ä½ç½®ï¼ˆå¯ä»¥æ·»åŠ åç§»ä»¥æ¨¡æ‹Ÿå…‰æŸå®½åº¦ï¼‰
                    let startPosition = source.mesh.position.clone();
                    if (offsetY !== 0) {
                        startPosition.y += offsetY;
                    }
                    
                    let currentRay = new BABYLON.Ray(startPosition, laserDirection, 200); // å¢åŠ å…‰çº¿é•¿åº¦
                    let currentIor = 1.0; // ç©ºæ°”æŠ˜å°„ç‡
                    let rayIntensity = 1.0; // å…‰çº¿å¼ºåº¦
                    
                    // å¢åŠ æœ€å¤§åå¼¹æ¬¡æ•°ä»¥è·å¾—æ›´ç²¾ç¡®çš„è¿½è¸ª
                    for (let i = 0; i < this.maxBounces; i++) {
                        // åªæ£€æµ‹å…‰å­¦ç»„ä»¶ï¼Œæ’é™¤å…‰æºæœ¬èº«
                        const opticalMeshes = this.components
                            .filter(comp => comp !== source && comp.mesh)
                            .map(comp => comp.mesh);
                        
                        const pickInfo = this.scene.pickWithRay(currentRay, (mesh) => 
                            opticalMeshes.includes(mesh)
                        );
                        
                        if (!pickInfo || !pickInfo.hit) {
                            // å…‰çº¿å»¶ä¼¸åˆ°åœºæ™¯è¾¹ç•Œ
                            const endPoint = currentRay.origin.add(currentRay.direction.scale(20));
                            this.drawRay(currentRay.origin, endPoint, source.properties.wavelength);
                            break;
                        }
                        
                        const hitMesh = pickInfo.pickedMesh;
                        const hitPoint = pickInfo.pickedPoint;
                        
                        // ç”»å‡ºåˆ°äº¤ç‚¹çš„å…‰çº¿
                        this.drawRay(currentRay.origin, hitPoint, source.properties.wavelength);
                        
                        const normal = pickInfo.getNormal(true);
                        const metadata = hitMesh.metadata;
                        
                        if (!metadata || !metadata.type) break;
                        
                        // æ ¹æ®å…‰å­¦ç»„ä»¶ç±»å‹å¤„ç†å…‰çº¿
                        if (metadata.type === "reflective") {
                            // åå°„
                            const reflectionDirection = BABYLON.Vector3.Reflect(currentRay.direction, normal);
                            currentRay = new BABYLON.Ray(hitPoint.add(reflectionDirection.scale(0.001)), reflectionDirection, 100);
                        } 
                        else if (metadata.type === "refractive") {
                            // æŠ˜å°„
                            const n1 = currentIor;
                            const n2 = (currentIor === 1.0) ? metadata.ior : 1.0;
                            
                            const cosI = -BABYLON.Vector3.Dot(currentRay.direction, normal);
                            const sinT2 = (n1 / n2) * (n1 / n2) * (1.0 - cosI * cosI);
                            
                            if (sinT2 > 1.0) { 
                                // å…¨å†…åå°„
                                const reflectionDirection = BABYLON.Vector3.Reflect(currentRay.direction, normal);
                                currentRay = new BABYLON.Ray(hitPoint.add(reflectionDirection.scale(0.001)), reflectionDirection, 100);
                            } else {
                                // æ–¯æ¶…å°”å®šå¾‹æŠ˜å°„
                                const cosT = Math.sqrt(1.0 - sinT2);
                                const refractionDirection = currentRay.direction.scale(n1 / n2)
                                    .add(normal.scale((n1 / n2) * cosI - cosT));
                                currentRay = new BABYLON.Ray(hitPoint.add(refractionDirection.scale(0.001)), refractionDirection, 100);
                                currentIor = n2;
                            }
                        }
                        else if (metadata.type === "diffractive") {
                            // ç®€åŒ–çš„è¡å°„å¤„ç†
                            const gratingComponent = metadata.component;
                            const wavelength = source.properties.wavelength || 632.8;
                            const gratingSpacing = 1.0 / (gratingComponent.properties.linesPerMM || 500);
                            
                            // è®¡ç®—ä¸€çº§è¡å°„
                            const incidentAngle = Math.acos(-BABYLON.Vector3.Dot(currentRay.direction, normal));
                            const sinDiffracted = Math.sin(incidentAngle) + (wavelength * 1e-6) / gratingSpacing;
                            
                                                        if (Math.abs(sinDiffracted) <= 1) {
                                const diffractedAngle = Math.asin(sinDiffracted);
                                
                                // è®¡ç®—è¡å°„æ–¹å‘
                                const right = normal.cross(BABYLON.Vector3.Up()).normalize();
                                const diffractedDirection = normal.scale(-Math.cos(diffractedAngle))
                                    .add(right.scale(Math.sin(diffractedAngle)));
                                
                                const diffractedRay = new BABYLON.Ray(hitPoint, diffractedDirection, 20);
                                const endPoint = diffractedRay.origin.add(diffractedRay.direction.scale(20));
                                
                                this.drawRay(diffractedRay.origin, endPoint, wavelength, 0.7);
                            }
                            
                            // é›¶çº§è¡å°„ï¼ˆç›´æ¥é€å°„ï¼‰
                            currentRay = new BABYLON.Ray(hitPoint.add(currentRay.direction.scale(0.001)), currentRay.direction, 100);
                        }
                        else {
                            // å¸æ”¶ (å¦‚å±å¹•)
                            break;
                        }
                    }
                } catch (error) {
                    console.error('å…‰çº¿è¿½è¸ªé”™è¯¯:', error);
                }
            }

            drawRay(start, end, wavelength = 632.8, intensity = 1.0) {
                try {
                    // é«˜æ€§èƒ½å…‰çº¿ç»˜åˆ¶
                    const line = BABYLON.MeshBuilder.CreateLines("rayLine", {
                        points: [start, end],
                        updatable: false, // ç¦ç”¨å¯æ›´æ–°ä»¥æå‡æ€§èƒ½
                        useVertexAlpha: false // ç¦ç”¨é¡¶ç‚¹alphaä»¥æå‡æ€§èƒ½
                    }, this.scene);
                    
                    // æ ¹æ®æ³¢é•¿è®¾ç½®é¢œè‰²
                    const color = this.wavelengthToColor(wavelength);
                    line.color = color.scale(intensity);
                    line.alpha = Math.min(0.9 * intensity, 0.95); // ç¨å¾®æé«˜alphaå€¼ä»¥è·å¾—æ›´å¥½çš„å¯è§æ€§
                    
                    // æ€§èƒ½ä¼˜åŒ–è®¾ç½®
                    line.isPickable = false; // ç¦ç”¨æ‹¾å–ä»¥æå‡æ€§èƒ½
                    line.doNotSyncBoundingInfo = true; // ç¦ç”¨è¾¹ç•Œä¿¡æ¯åŒæ­¥
                    line.freezeWorldMatrix(); // å†»ç»“ä¸–ç•ŒçŸ©é˜µä»¥æå‡æ€§èƒ½
                    
                    this.rayLines.push(line);
                } catch (error) {
                    console.error('ç»˜åˆ¶å…‰çº¿é”™è¯¯:', error);
                }
            }

            wavelengthToColor(wavelength) {
                let r, g, b;
                
                if (wavelength >= 380 && wavelength < 440) {
                    r = -(wavelength - 440) / (440 - 380);
                    g = 0.0;
                    b = 1.0;
                } else if (wavelength >= 440 && wavelength < 490) {
                    r = 0.0;
                    g = (wavelength - 440) / (490 - 440);
                    b = 1.0;
                } else if (wavelength >= 490 && wavelength < 510) {
                    r = 0.0;
                    g = 1.0;
                    b = -(wavelength - 510) / (510 - 490);
                } else if (wavelength >= 510 && wavelength < 580) {
                    r = (wavelength - 510) / (580 - 510);
                    g = 1.0;
                    b = 0.0;
                } else if (wavelength >= 580 && wavelength < 645) {
                    r = 1.0;
                    g = -(wavelength - 645) / (645 - 580);
                    b = 0.0;
                } else if (wavelength >= 645 && wavelength <= 750) {
                    r = 1.0;
                    g = 0.0;
                    b = 0.0;
                } else {
                    r = 1.0;
                    g = 0.0;
                    b = 0.0;
                }
                
                return new BABYLON.Color3(r, g, b);
            }

            updateSystemInfo() {
                try {
                    const rayInfo = document.getElementById('rayInfo');
                    const performanceInfo = document.getElementById('performanceInfo');
                    const distanceInfo = document.getElementById('distanceInfo');
                    
                    if (rayInfo) {
                        rayInfo.innerHTML = `
                            <strong>å…‰çº¿ä¿¡æ¯:</strong><br>
                            å…‰çº¿æ®µæ•°: ${this.rayLines.length}<br>
                            ç»„ä»¶æ•°é‡: ${this.components.length}<br>
                            å…‰æºæ•°é‡: ${this.components.filter(c => c.type === 'laser').length}<br>
                            ${this.selectedComponent ? `<span style="color: #00ff88;">é€‰ä¸­: ${this.selectedComponent.type} (${this.transformMode})</span>` : ''}
                        `;
                    }
                    
                    if (performanceInfo && this.engine) {
                        const fps = this.engine.getFps();
                        const drawCalls = this.scene.getActiveMeshes().length;
                        const totalVertices = this.scene.getTotalVertices();
                        const memoryUsage = this.scene.meshes.length + this.rayLines.length;
                        
                        performanceInfo.innerHTML = `
                            <strong>å®æ—¶æ€§èƒ½ä¿¡æ¯:</strong><br>
                            FPS: ${fps.toFixed(1)} ${fps >= 60 ? 'ğŸŸ¢' : fps >= 30 ? 'ğŸŸ¡' : 'ğŸ”´'}<br>
                            ç»˜åˆ¶è°ƒç”¨: ${drawCalls}<br>
                            æ´»åŠ¨ç½‘æ ¼: ${this.scene.meshes.length}<br>
                            æ€»é¡¶ç‚¹æ•°: ${totalVertices}<br>
                            å…‰çº¿æ•°é‡: ${this.rayLines.length}<br>
                            å†…å­˜ä½¿ç”¨: ${memoryUsage} å¯¹è±¡<br>
                            ${this.enableRealtimeRayTracing ? '<span style="color: #00ff88;">âš¡ å®æ—¶å…‰çº¿è¿½è¸ª</span>' : '<span style="color: #ffaa00;">â¸ï¸ é™åˆ¶æ¨¡å¼</span>'}
                        `;
                    }
                    
                    if (distanceInfo && this.components.length >= 2) {
                        let html = '<strong>ç»„ä»¶é—´è·ç¦»:</strong><br>';
                        let count = 0;
                        
                        // ä¼˜å…ˆæ˜¾ç¤ºå…‰æºåˆ°å…¶ä»–ç»„ä»¶çš„è·ç¦»
                        const lasers = this.components.filter(c => c.type === 'laser');
                        const others = this.components.filter(c => c.type !== 'laser');
                        
                        for (let laser of lasers) {
                            for (let other of others) {
                                if (count >= 3) break;
                                
                                const distance = BABYLON.Vector3.Distance(
                                    laser.mesh.position,
                                    other.mesh.position
                                );
                                
                                html += `${laser.type} â†’ ${other.type}: ${(distance * 10).toFixed(1)} mm<br>`;
                                count++;
                            }
                            if (count >= 3) break;
                        }
                        
                        distanceInfo.innerHTML = html;
                    } else if (distanceInfo) {
                        distanceInfo.innerHTML = '<strong>è·ç¦»ä¿¡æ¯:</strong><br>éœ€è¦è‡³å°‘2ä¸ªç»„ä»¶';
                    }
                } catch (error) {
                    console.error('æ›´æ–°ç³»ç»Ÿä¿¡æ¯é”™è¯¯:', error);
                }
            }

            // ğŸ”¥ æé™æ€§èƒ½ä¼˜åŒ–è®¾ç½®
            setupExtremePerformanceMode() {
                // ä¸´æ—¶ç¦ç”¨æé™æ€§èƒ½æ¨¡å¼æ¥æµ‹è¯•é¼ æ ‡æ‹¾å–
                console.log('âš ï¸ æé™æ€§èƒ½æ¨¡å¼å·²ä¸´æ—¶ç¦ç”¨ä»¥ç¡®ä¿é¼ æ ‡æ‹¾å–åŠŸèƒ½æ­£å¸¸');
                return;
                
                if (!this.enableHighPerformanceMode) return;
                
                console.log('ğŸ”¥ é…ç½®æé™æ€§èƒ½æ¨¡å¼...');
                
                // åœºæ™¯çº§åˆ«æé™ä¼˜åŒ–
                this.scene.skipPointerMovePicking = true; // è·³è¿‡æŒ‡é’ˆç§»åŠ¨æ‹¾å–
                this.scene.skipPointerDownPicking = false; // ä¿ç•™ç‚¹å‡»æ‹¾å–
                this.scene.skipPointerUpPicking = true; // è·³è¿‡æŒ‡é’ˆæŠ¬èµ·æ‹¾å–
                this.scene.constantlyUpdateMeshUnderPointer = false; // ç¦ç”¨æŒç»­æ›´æ–°æŒ‡é’ˆä¸‹ç½‘æ ¼
                this.scene.hoverCursor = 'default'; // ç®€åŒ–é¼ æ ‡æ ·å¼
                
                // æ¸²æŸ“ä¼˜åŒ–
                this.scene.autoClear = true; // è‡ªåŠ¨æ¸…é™¤
                this.scene.autoClearDepthAndStencil = false; // ç¦ç”¨æ·±åº¦æ¨¡æ¿è‡ªåŠ¨æ¸…é™¤ä»¥èŠ‚çœGPUæ—¶é—´
                
                // å¼ºåˆ¶è®¾ç½®é«˜åˆ†è¾¨ç‡çº¹ç†å’Œå¤æ‚å‡ ä½•ä½“ä»¥å¢åŠ GPUè´Ÿè½½
                this.scene.getEngine().setSize(Math.max(1920, window.innerWidth), Math.max(1080, window.innerHeight), false);
                
                // WebGLæé™ä¼˜åŒ–
                const gl = this.engine._gl;
                if (gl) {
                    // å¯ç”¨æ‰€æœ‰å¯ç”¨çš„WebGLæ‰©å±•
                    const extensions = [
                        'OES_texture_float',
                        'OES_texture_float_linear',
                        'WEBGL_depth_texture',
                        'OES_element_index_uint',
                        'WEBGL_lose_context',
                        'WEBGL_compressed_texture_s3tc',
                        'WEBGL_compressed_texture_pvrtc',
                        'WEBGL_compressed_texture_etc1',
                        'EXT_texture_filter_anisotropic',
                        'WEBGL_draw_buffers'
                    ];
                    
                    extensions.forEach(ext => {
                        const extension = gl.getExtension(ext);
                        if (extension) {
                            console.log(`âœ… WebGLæ‰©å±•å·²å¯ç”¨: ${ext}`);
                        }
                    });
                    
                    // æ˜¾ç¤ºGPUä¿¡æ¯
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    if (debugInfo) {
                        console.log('ğŸ® GPUå‹å·:', gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL));
                        console.log('ğŸ¢ GPUå‚å•†:', gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL));
                    }
                    
                    // è·å–å¹¶æ˜¾ç¤ºWebGLé™åˆ¶ä¿¡æ¯
                    console.log('ğŸ“Š WebGLæé™å‚æ•°:');
                    console.log('  æœ€å¤§çº¹ç†å°ºå¯¸:', gl.getParameter(gl.MAX_TEXTURE_SIZE));
                    console.log('  æœ€å¤§ç«‹æ–¹ä½“çº¹ç†å°ºå¯¸:', gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE));
                    console.log('  æœ€å¤§é¡¶ç‚¹å±æ€§:', gl.getParameter(gl.MAX_VERTEX_ATTRIBS));
                    console.log('  æœ€å¤§é¡¶ç‚¹çº¹ç†å•å…ƒ:', gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS));
                    console.log('  æœ€å¤§ç‰‡æ®µçº¹ç†å•å…ƒ:', gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS));
                    console.log('  æœ€å¤§æ¸²æŸ“ç¼“å†²åŒºå°ºå¯¸:', gl.getParameter(gl.MAX_RENDERBUFFER_SIZE));
                    
                    // è®¾ç½®WebGLçŠ¶æ€ä»¥æœ€å¤§åŒ–æ€§èƒ½
                    gl.enable(gl.DEPTH_TEST);
                    gl.enable(gl.CULL_FACE);
                    gl.cullFace(gl.BACK);
                    gl.frontFace(gl.CCW);
                }
                
                // å¼ºåˆ¶å¯ç”¨æ‰€æœ‰Babylon.jsæ€§èƒ½é€‰é¡¹
                this.engine.loadingUIBackgroundColor = '#000000';
                this.engine.enableOfflineSupport = false;
                this.engine.disableManifestCheck = true;
                
                // åˆ›å»ºå¤§é‡å¤æ‚å‡ ä½•ä½“ä»¥å¢åŠ GPUå·¥ä½œè´Ÿè½½
                this.createPerformanceTestObjects();
                
                console.log('ğŸš€ æé™æ€§èƒ½æ¨¡å¼é…ç½®å®Œæˆï¼');
            }
            
            // åˆ›å»ºæ€§èƒ½æµ‹è¯•å¯¹è±¡ä»¥å¢åŠ GPUè´Ÿè½½
            createPerformanceTestObjects() {
                if (!this.enableHighPerformanceMode) return;
                
                console.log('ğŸ”§ åˆ›å»ºGPUè´Ÿè½½æµ‹è¯•å¯¹è±¡...');
                
                // åˆ›å»ºé«˜å¤šè¾¹å½¢ç½‘æ ¼ä»¥å¢åŠ GPUè´Ÿè½½
                const testMeshes = [];
                for (let i = 0; i < 10; i++) {
                    // åˆ›å»ºé«˜ç»†åˆ†åº¦çš„çƒä½“
                    const sphere = BABYLON.MeshBuilder.CreateSphere(`perfTestSphere${i}`, {
                        diameter: 0.1,
                        segments: 32 // é«˜ç»†åˆ†åº¦
                    }, this.scene);
                    
                    sphere.position = new BABYLON.Vector3(
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 20
                    );
                    
                    // åˆ›å»ºå¤æ‚æè´¨
                    const material = new BABYLON.StandardMaterial(`perfTestMat${i}`, this.scene);
                    material.diffuseColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random());
                    material.specularColor = new BABYLON.Color3(1, 1, 1);
                    material.specularPower = 64;
                    material.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                    
                    sphere.material = material;
                    sphere.isVisible = false; // éšè—ä½†ä»å‚ä¸æ¸²æŸ“è®¡ç®—
                    testMeshes.push(sphere);
                }
                
                // æ·»åŠ åŠ¨ç”»ä»¥å¢åŠ æ¯å¸§è®¡ç®—è´Ÿè½½
                this.scene.registerBeforeRender(() => {
                    testMeshes.forEach((mesh, index) => {
                        mesh.rotation.x += 0.01 * (index + 1);
                        mesh.rotation.y += 0.005 * (index + 1);
                        mesh.position.y = Math.sin(Date.now() * 0.001 + index) * 0.5;
                    });
                });
                
                console.log(`âœ… å·²åˆ›å»º ${testMeshes.length} ä¸ªGPUè´Ÿè½½æµ‹è¯•å¯¹è±¡`);
            }

            startRenderLoop() {
                console.log('ğŸ”¥ å¯åŠ¨æé™æ€§èƒ½æ¸²æŸ“å¾ªç¯...');
                
                // è®¾ç½®æœ€å¤§å¸§ç‡ï¼ˆç§»é™¤é™åˆ¶ï¼‰
                this.engine.setSize(window.innerWidth, window.innerHeight, false);
                
                // å¼ºåˆ¶WebGLçŠ¶æ€ä¼˜åŒ–
                const gl = this.engine._gl;
                if (gl) {
                    // è®¾ç½®æœ€å¤§è§†çª—
                    gl.viewport(0, 0, window.innerWidth, window.innerHeight);
                    // å…³é—­ä¸å¿…è¦çš„WebGLåŠŸèƒ½
                    gl.disable(gl.SCISSOR_TEST);
                    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
                    gl.disable(gl.SAMPLE_COVERAGE);
                }
                
                // æé™æ€§èƒ½æ¸²æŸ“å¾ªç¯
                this.engine.runRenderLoop(() => {
                    if (this.scene && this.scene.isReady()) {
                        // å¼ºåˆ¶æ¯å¸§æ¸²æŸ“
                        this.scene.render();
                        
                        // å¼ºåˆ¶GPUå·¥ä½œè´Ÿè½½ï¼ˆå¢åŠ è®¡ç®—å¤æ‚åº¦ï¼‰
                        if (this.enableHighPerformanceMode) {
                            // é¢å¤–çš„GPUè®¡ç®—è´Ÿè½½
                            this.scene.forceShowBoundingBoxes = false;
                            this.scene.forceWireframe = false;
                            
                            // å¼ºåˆ¶æè´¨æ›´æ–°ä»¥å¢åŠ GPUè´Ÿè½½
                            if (this.components.length > 0 && this.forceRender) {
                                this.scene.markAllMaterialsAsDirty(BABYLON.Material.AllDirtyFlag);
                                
                                // å¼ºåˆ¶é‡æ–°è®¡ç®—æ‰€æœ‰ç½‘æ ¼
                                this.scene.meshes.forEach(mesh => {
                                    if (mesh.geometry) {
                                        mesh.refreshBoundingInfo();
                                    }
                                });
                            }
                        }
                    }
                });
                
                // é¢å¤–çš„æ€§èƒ½ä¼˜åŒ–è®¾ç½®
                if (this.enableHighPerformanceMode) {
                    // å¯ç”¨å¼•æ“æé™ä¼˜åŒ–
                    this.engine.enableOfflineSupport = false;
                    this.engine.doNotHandleContextLost = true;
                    
                    // å®šæœŸå¼ºåˆ¶åƒåœ¾å›æ”¶ï¼ˆæ§åˆ¶å†…å­˜ä»¥æœ€å¤§åŒ–GPUåˆ©ç”¨ï¼‰
                    setInterval(() => {
                        if (this.scene.getEngine().drawCalls > 500) {
                            this.scene.cleanCachedTextureBuffer();
                        }
                    }, 1000);
                    
                    console.log('ğŸš€ æé™æ€§èƒ½æ¸²æŸ“å¾ªç¯å·²å¯åŠ¨ - GPUåˆ©ç”¨ç‡æœ€å¤§åŒ–æ¨¡å¼');
                } else {
                    console.log('æ ‡å‡†æ¸²æŸ“å¾ªç¯å·²å¯åŠ¨');
                }
            }

            dispose() {
                // æ¸…ç†æ‰€æœ‰ç»„ä»¶
                this.components.forEach(comp => {
                    if (comp.mesh) {
                        comp.mesh.dispose();
                    }
                });
                
                // æ¸…ç†å…‰çº¿
                this.rayLines.forEach(line => line.dispose());
                
                // æ¸…ç†å›è°ƒ
                if (window.sliderCallbacks) {
                    window.sliderCallbacks = {};
                }
                if (window.colorCallbacks) {
                    window.colorCallbacks = {};
                }
                
                if (this.scene) {
                    this.scene.dispose();
                }
                if (this.engine) {
                    this.engine.dispose();
                }
            }
        }

        // å…¨å±€å˜é‡ä¾›æŒ‰é’®è°ƒç”¨
        let opticalSystemGame = null;

        // åˆå§‹åŒ–æ¸¸æˆ
        async function initializeGame() {
            try {
                console.log('å¼€å§‹åˆå§‹åŒ–æ¸¸æˆ...');
                opticalSystemGame = new OpticalSystem();
            } catch (error) {
                console.error('æ¸¸æˆåˆå§‹åŒ–å¤±è´¥:', error);
                
                // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
                const loadingScreen = document.getElementById('loadingScreen');
                if (loadingScreen) {
                    loadingScreen.innerHTML = `
                        <div style="color: #ff4444; text-align: center; padding: 20px;">
                            <h3>âŒ åˆå§‹åŒ–å¤±è´¥</h3>
                            <p style="margin: 20px 0;">${error.message}</p>
                            <p style="font-size: 12px;">é”™è¯¯è¯¦æƒ…: ${error.stack}</p>
                            <button onclick="location.reload()" style="padding: 10px 20px; background: #ff4444; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 10px;">
                                é‡æ–°åŠ è½½
                            </button>
                        </div>
                    `;
                }
            }
        }

        // ç­‰å¾…é¡µé¢å®Œå…¨åŠ è½½ååˆå§‹åŒ–
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeGame);
        } else {
            initializeGame();
        }

        // é˜²æ­¢é¡µé¢åˆ·æ–°ä¸¢å¤±
        window.addEventListener('beforeunload', (event) => {
            if (opticalSystemGame && opticalSystemGame.components && opticalSystemGame.components.length > 0) {
                event.preventDefault();
                event.returnValue = 'æ‚¨ç¡®å®šè¦ç¦»å¼€å—ï¼Ÿæœªä¿å­˜çš„è®¾è®¡å°†ä¸¢å¤±ã€‚';
            }
        });

        // å…¨å±€é”™è¯¯å¤„ç†
        window.addEventListener('error', (event) => {
            console.error('JavaScripté”™è¯¯:', event.error);
            
            // å¦‚æœæ˜¯åˆå§‹åŒ–é˜¶æ®µçš„é”™è¯¯ï¼Œæ˜¾ç¤ºå‹å¥½æç¤º
            if (!opticalSystemGame || !opticalSystemGame.engine) {
                const loadingScreen = document.getElementById('loadingScreen');
                if (loadingScreen && !loadingScreen.classList.contains('hidden')) {
                    loadingScreen.innerHTML = `
                        <div style="color: #ff4444; text-align: center; padding: 20px;">
                            <h3>âŒ å‘ç”Ÿé”™è¯¯</h3>
                            <p style="margin: 20px 0;">ç¨‹åºåˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•ã€‚</p>
                            <p style="font-size: 12px; color: #ccc;">è¯¦ç»†é”™è¯¯ä¿¡æ¯è¯·æŸ¥çœ‹æµè§ˆå™¨æ§åˆ¶å°</p>
                        </div>
                    `;
                }
            }
        });

        </script>
    </body>
    </html>